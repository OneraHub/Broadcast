! This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of impli_matrix_free_rans_2d in reverse (adjoint) mode (with options with!SliceDeadControl with!SliceDeadInstr
!s with!StaticTaping):
!   gradient     of useful results: cfl dw w muref sigma nx ny
!                prandtl tref vol dtcoef volf s_suth src_i cs rgaz
!                cv dwi gam
!   with respect to varying inputs: cfl dw w muref sigma nx ny
!                prandtl tref vol dtcoef volf s_suth src_i cs rgaz
!                cv dwi gam
!   RW status of diff variables: cfl:incr dw:incr w:incr muref:incr
!                sigma:incr nx:incr ny:incr prandtl:incr tref:incr
!                vol:incr dtcoef:incr volf:incr s_suth:incr src_i:incr
!                cs:incr rgaz:incr cv:incr dwi:in-zero gam:incr
! =============================================================================
!                Implicit matrix free phase 2D RANS coupled
! =============================================================================
SUBROUTINE IMPLI_MATRIX_FREE_RANS_2D_B(dwi, dwib, nx, nxb, ny, nyb, &
& src_i, src_ib, w, wb, mut, dw, dwb, vol, volb, volf, volfb, dtcoef, &
& dtcoefb, cfl, cflb, sigma, sigmab, gam, gamb, rgaz, rgazb, prandtl, &
& prandtlb, prandtlturb, lmax, gh, cv, cvb, cs, csb, muref, murefb, tref&
& , trefb, s_suth, s_suthb, im, jm, em)
  IMPLICIT NONE
!
!
! variables for dimension -----------------------------------------
  INTEGER, INTENT(IN) :: em, im, jm, lmax
  INTEGER, INTENT(IN) :: gh
! required arguments ----------------------------------------------
  REAL*8, INTENT(IN) :: dtcoef, gam, rgaz, prandtl, prandtlturb, sigma
  REAL*8 :: dtcoefb, gamb, rgazb, prandtlb, sigmab
  REAL*8, INTENT(IN) :: cv, cfl, cs, muref, tref, s_suth
  REAL*8 :: cvb, cflb, csb, murefb, trefb, s_suthb
  REAL*8, DIMENSION(1-gh:im+1+gh, 1-gh:jm+1+gh, 2), INTENT(IN) :: nx, ny
  REAL*8, DIMENSION(1-gh:im+1+gh, 1-gh:jm+1+gh, 2) :: nxb, nyb
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2), INTENT(IN) :: volf
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2) :: volfb
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: vol
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: volb
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(IN) :: w
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em) :: wb
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(IN) :: dw
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em) :: dwb
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: mut
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: src_i
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: src_ib
! Returned objects ------------------------------------------------
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(INOUT) :: dwi
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(INOUT) :: dwib
! Local variables -------------------------------------------------
  INTEGER :: i, j, l, equa, kdir, i0, j0, ipt, le, eq2
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: mu, tloc
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: mub, tlocb
  REAL*8, DIMENSION(0:im+1, 0:jm+1, em) :: d2w, dfi, dgi, hn, f, g
  REAL*8, DIMENSION(0:im+1, 0:jm+1, em) :: d2wb, dfib, dgib, hnb, fb, gb
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2) :: coefdiag
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2) :: coefdiagb
!specrad
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2, 2) :: coef
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2, 2) :: coefb
  REAL*8, DIMENSION(em) :: wi, fi, gi
  REAL*8, DIMENSION(em) :: wib, fib, gib
  REAL*8 :: velxi, velyi, velzi, pint, tint, htot
  REAL*8 :: velxib, velyib, velzib, pintb, htotb
  REAL*8 :: rhom1, roki, norm, specdiff, iro, rol, ror, sigmainv
  REAL*8 :: rhom1b, normb, specdiffb, irob, rolb, rorb, sigmainvb
  REAL*8 :: one, half, zero, two, rom1l, rom1r, gampr, gamprt, mutot, &
& difftur
  REAL*8 :: rom1lb, rom1rb, gamprb, mutotb, diffturb
  REAL*8 :: uu, vv, cc, gam1, itur
  REAL*8 :: uub, vvb, ccb, gam1b
  REAL*8 :: dist, vitc, dt_euler, dt_ns, cflm1, distm1, cvm1
  REAL*8 :: distb, vitcb, dt_eulerb, dt_nsb, cflm1b, cvm1b
  REAL*8 :: ec, eloc, betas, rom1, dtm1, dt
  REAL*8 :: ecb, elocb, betasb, rom1b, dtm1b
  INTRINSIC SQRT
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC ABS
  REAL*8 :: x1
  REAL*8 :: x1b
  REAL*8 :: x2
  REAL*8 :: x2b
  REAL*8 :: x3
  REAL*8 :: x3b
  REAL*8 :: max1
  REAL*8 :: max1b
  REAL*8 :: abs0
  REAL*8 :: abs0b
  REAL*8 :: abs1
  REAL*8 :: abs1b
  REAL*8 :: temp
  REAL*8 :: tempb
  REAL*8 :: temp0
  REAL*8 :: tempb0
  REAL*8 :: temp1
  REAL*8 :: tempb1
  REAL*8 :: temp2
  REAL*8 :: temp3
  REAL*8 :: tempb2
  REAL*8 :: tempb3
  INTEGER, DIMENSION(2) :: ad_save
  INTEGER, DIMENSION(2) :: ad_save0
  REAL*8, DIMENSION(em) :: tempb4
  REAL*8, DIMENSION(em) :: tempb5
  REAL*8, DIMENSION(im, jm) :: temp4
  REAL*8, DIMENSION(im, jm) :: tempb6
  INTEGER :: branch
  INTEGER :: ad_to
  INTEGER :: ad_to0
! -----------------------------------------------------------------
  half = 0.5d0
  zero = 0.d0
  two = 2.d0
  one = 1.d0
!
  dwi = zero
  dfi = zero
  dgi = zero
!
  gampr = 2.d0*gam/prandtl
  gam1 = gam - one
!
  cflm1 = one/cfl
  cvm1 = one/cv
  betas = muref*(tref+cs)/(SQRT(tref)*tref)
  sigmainv = one/sigma
  DO j=1-gh,jm+gh
    DO i=1-gh,im+gh
      CALL PUSHREAL8(ror)
      ror = w(i, j, 1)
      rom1 = one/ror
      velxi = w(i, j, 2)*rom1
      velyi = w(i, j, 3)*rom1
      velzi = w(i, j, 4)*rom1
!
      ec = half*(velxi*velxi+velyi*velyi+velzi*velzi)
!
      eloc = (w(i, j, 5)-ec*ror)*rom1
!
      tloc(i, j) = eloc*cvm1
!
      pint = ror*rgaz*tloc(i, j)
      htot = (w(i, j, 5)+pint)*rom1
      f(i, j, 1) = w(i, j, 2)
      f(i, j, 2) = w(i, j, 2)*velxi + pint
      f(i, j, 3) = w(i, j, 2)*velyi
      f(i, j, 4) = w(i, j, 2)*velzi
      f(i, j, 5) = w(i, j, 2)*htot
      g(i, j, 1) = w(i, j, 3)
      g(i, j, 2) = w(i, j, 3)*velxi
      g(i, j, 3) = w(i, j, 3)*velyi + pint
      g(i, j, 4) = w(i, j, 3)*velzi
      g(i, j, 5) = w(i, j, 3)*htot
!h(i,j,1)  = w(i,j,4)
!h(i,j,2)  = w(i,j,4) * velx(i,j)
!h(i,j,3)  = w(i,j,4) * vely(i,j)
!h(i,j,4)  = w(i,j,4) * velz(i,j) + pint
!h(i,j,5)  = w(i,j,4) * htot
      mu(i, j) = betas/(tloc(i, j)+s_suth)*SQRT(tloc(i, j))*tloc(i, j)
      DO itur=6,em
        f(i, j, itur) = w(i, j, 2)*w(i, j, itur)*rom1
        g(i, j, itur) = w(i, j, 3)*w(i, j, itur)*rom1
      END DO
      CALL PUSHREAL8(dist)
      dist = vol(i, j)/(SQRT(nx(i, j, 1)*nx(i, j, 1)+ny(i, j, 1)*ny(i, j&
&       , 1))+SQRT(nx(i, j, 2)*nx(i, j, 2)+ny(i, j, 2)*ny(i, j, 2)))
      cc = SQRT(gam*pint*rom1)
      CALL PUSHREAL8(vitc)
      vitc = SQRT(velxi*velxi + velyi*velyi) + cc
      dt_euler = dist/vitc
      dt_ns = half*dist*dist*ror/(gampr*mu(i, j))
      IF (dt_euler .GT. dt_ns) THEN
        x1 = dt_ns
        CALL PUSHCONTROL1B(0)
      ELSE
        x1 = dt_euler
        CALL PUSHCONTROL1B(1)
      END IF
      IF (x1 .LT. 1.d-15) THEN
        CALL PUSHREAL8(max1)
        max1 = 1.d-15
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8(max1)
        max1 = x1
        CALL PUSHCONTROL1B(1)
      END IF
! 1/dt
      dtm1 = cflm1/max1
!write(30101,*) "i,j    =  ", i,j
!write(30101,*) "dtm1   =  ", dtm1
!write(30101,*) "distm1 =  ", distm1
!write(30101,*) "cflm1  =  ", dtm1
!write(30101,*) "mu     =  ", mu(i,j)
! compute diagonal coefficient------------------------------------------------------
! 1/dt ou 1.5/dt
      coefdiag(1:im, 1:jm, 1) = dtcoef*dtm1*vol(1:im, 1:jm)
! 1/dt ou 1.5/dt
      coefdiag(1:im, 1:jm, 2) = dtcoef*dtm1*vol(1:im, 1:jm)
    END DO
  END DO
!
loop_kdir:DO kdir=1,2
    ad_save(kdir) = i0
    i0 = -kdir + 2
    ad_save0(kdir) = j0
    j0 = kdir - 1
!
    DO j=1,jm+1
      DO i=1,im+1
        CALL PUSHREAL8(rol)
        rol = w(i-i0, j-j0, 1)
        CALL PUSHREAL8(ror)
        ror = w(i, j, 1)
        CALL PUSHREAL8(rom1l)
        rom1l = one/rol
        CALL PUSHREAL8(rom1r)
        rom1r = one/ror
        CALL PUSHREAL8(iro)
        iro = 2.d0/(rol+ror)
        CALL PUSHREAL8(uu)
        uu = half*(w(i-i0, j-j0, 2)*rom1l+w(i, j, 2)*rom1r)
        CALL PUSHREAL8(vv)
        vv = half*(w(i-i0, j-j0, 3)*rom1l+w(i, j, 3)*rom1r)
        cc = gam*rgaz*half*(tloc(i-i0, j-j0)+tloc(i, j))
        CALL PUSHREAL8(norm)
        norm = nx(i, j, kdir)*nx(i, j, kdir) + ny(i, j, kdir)*ny(i, j, &
&         kdir)
        CALL PUSHREAL8(mutot)
        mutot = half*gampr*(mu(i-i0, j-j0)+mu(i, j))
        specdiff = mutot*norm*volf(i, j, kdir)*iro
        x2 = uu*nx(i, j, kdir) + vv*ny(i, j, kdir)
        IF (x2 .GE. 0.) THEN
          abs0 = x2
          CALL PUSHCONTROL1B(0)
        ELSE
          abs0 = -x2
          CALL PUSHCONTROL1B(1)
        END IF
        coef(i, j, 1, kdir) = 0.5d0*(abs0+SQRT(cc*norm)+two*specdiff)
        mutot = half*(mu(i-i0, j-j0)+mu(i, j)+w(i-i0, j-j0, 6)+w(i, j, 6&
&         ))
! mutot = HALF * ( mu(i-i0,j-j0) + mu(i,j) + mut(i-i0,j-j0) + mut(i,j) )
        difftur = mutot*sigmainv*norm*volf(i, j, kdir)*iro
        x3 = uu*nx(i, j, kdir) + vv*ny(i, j, kdir)
        IF (x3 .GE. 0.) THEN
          abs1 = x3
          CALL PUSHCONTROL1B(0)
        ELSE
          abs1 = -x3
          CALL PUSHCONTROL1B(1)
        END IF
        coef(i, j, 2, kdir) = 0.5d0*(abs1+SQRT(cc*norm)+two*difftur)
      END DO
    END DO
    DO j=1,jm
      DO i=1,im
        coefdiag(i, j, 1) = coefdiag(i, j, 1) + coef(i, j, 1, kdir) + &
&         coef(i+i0, j+j0, 1, kdir)
        coefdiag(i, j, 2) = coefdiag(i, j, 2) + coef(i, j, 2, kdir) + &
&         coef(i+i0, j+j0, 2, kdir)
      END DO
    END DO
  END DO loop_kdir
!
loop_subite:DO l=1,lmax
!
    DO equa=1,em
      CALL PUSHREAL8ARRAY(d2w(:, :, equa), (im+2)*(jm+2))
      d2w(0:im+1, 0:jm+1, equa) = dw(0:im+1, 0:jm+1, equa)*vol(0:im+1, 0&
&       :jm+1)
    END DO
!
! Computation of the left hand side
!
loop_kdir_inner:DO kdir=1,2
      CALL PUSHINTEGER4(i0)
      i0 = -kdir + 2
      CALL PUSHINTEGER4(j0)
      j0 = kdir - 1
!
      DO j=1,jm+j0
        DO i=1,im+i0
!norm = dsqrt( nx(i,j,kdir)**2 + ny(i,j,kdir)**2)
          hn(i, j, :) = half*(dfi(i-i0, j-j0, :)+dfi(i, j, :))*nx(i, j, &
&           kdir) + half*(dgi(i-i0, j-j0, :)+dgi(i, j, :))*ny(i, j, kdir&
&           )
        END DO
        CALL PUSHINTEGER4(i - 1)
      END DO
      CALL PUSHINTEGER4(j - 1)
!
      DO j=1,jm
        DO i=1,im
          CALL PUSHREAL8ARRAY(d2w(i, j, 1:5), 5)
          d2w(i, j, 1:5) = d2w(i, j, 1:5) + hn(i, j, 1:5) - hn(i+i0, j+&
&           j0, 1:5) + coef(i, j, 1, kdir)*dwi(i-i0, j-j0, 1:5) + coef(i&
&           +i0, j+j0, 1, kdir)*dwi(i+i0, j+j0, 1:5)
        END DO
      END DO
      DO equa=6,em
        DO j=1,jm
          DO i=1,im
            CALL PUSHREAL8(d2w(i, j, equa))
            d2w(i, j, equa) = d2w(i, j, equa) + hn(i, j, equa) - hn(i+i0&
&             , j+j0, equa) + coef(i, j, 2, kdir)*dwi(i-i0, j-j0, equa) &
&             + coef(i+i0, j+j0, 2, kdir)*dwi(i+i0, j+j0, equa)
          END DO
        END DO
      END DO
    END DO loop_kdir_inner
!
! Computation of the intermediate increment
!
    CALL PUSHREAL8ARRAY(dwi(1:im, 1:jm, 1), im*jm)
    dwi(1:im, 1:jm, 1) = d2w(1:im, 1:jm, 1)/coefdiag(1:im, 1:jm, 1)
    CALL PUSHREAL8ARRAY(dwi(1:im, 1:jm, 2), im*jm)
    dwi(1:im, 1:jm, 2) = d2w(1:im, 1:jm, 2)/coefdiag(1:im, 1:jm, 1)
    CALL PUSHREAL8ARRAY(dwi(1:im, 1:jm, 3), im*jm)
    dwi(1:im, 1:jm, 3) = d2w(1:im, 1:jm, 3)/coefdiag(1:im, 1:jm, 1)
    CALL PUSHREAL8ARRAY(dwi(1:im, 1:jm, 4), im*jm)
    dwi(1:im, 1:jm, 4) = d2w(1:im, 1:jm, 4)/coefdiag(1:im, 1:jm, 1)
    CALL PUSHREAL8ARRAY(dwi(1:im, 1:jm, 5), im*jm)
    dwi(1:im, 1:jm, 5) = d2w(1:im, 1:jm, 5)/coefdiag(1:im, 1:jm, 1)
    DO equa=6,em
      CALL PUSHREAL8ARRAY(dwi(1:im, 1:jm, equa), im*jm)
      dwi(1:im, 1:jm, equa) = d2w(1:im, 1:jm, equa)/(coefdiag(1:im, 1:jm&
&       , 2)+src_i(1:im, 1:jm))
    END DO
!
! Actualisation de wi
!
    DO j=1,jm
      DO i=1,im
        wi(:) = w(i, j, :) + dwi(i, j, :)
        rhom1 = one/wi(1)
        velxi = wi(2)*rhom1
        velyi = wi(3)*rhom1
        velzi = wi(4)*rhom1
        CALL PUSHREAL8(pint)
        pint = gam1*(wi(5)-half*wi(1)*(velxi*velxi+velyi*velyi+velzi*&
&         velzi))
!
! Actualisation des flux intermediaires
        fi(1) = wi(2)
        fi(2) = wi(2)*velxi + pint
        fi(3) = wi(2)*velyi
        fi(4) = wi(2)*velzi
        fi(5) = velxi*(wi(5)+pint)
        gi(1) = wi(3)
        gi(2) = wi(3)*velxi
        gi(3) = wi(3)*velyi + pint
        gi(4) = wi(3)*velzi
        gi(5) = velyi*(wi(5)+pint)
! turbulent quantities
        fi(6:em) = velxi*wi(6:em)
        gi(6:em) = velyi*wi(6:em)
! Calcul des increments des flux
        CALL PUSHREAL8ARRAY(dfi(i, j, :), em)
        dfi(i, j, :) = fi(:) - f(i, j, :)
        CALL PUSHREAL8ARRAY(dgi(i, j, :), em)
        dgi(i, j, :) = gi(:) - g(i, j, :)
      END DO
    END DO
  END DO loop_subite
  fb = 0.0_8
  gb = 0.0_8
  coefb = 0.0_8
  gam1b = 0.0_8
  coefdiagb = 0.0_8
  hnb = 0.0_8
  fib = 0.0_8
  dfib = 0.0_8
  d2wb = 0.0_8
  gib = 0.0_8
  dgib = 0.0_8
  DO l=lmax,1,-1
    DO j=jm,1,-1
      DO i=im,1,-1
        CALL POPREAL8ARRAY(dgi(i, j, :), em)
        gib = gib + dgib(i, j, :)
        gb(i, j, :) = gb(i, j, :) - dgib(i, j, :)
        dgib(i, j, :) = 0.0_8
        CALL POPREAL8ARRAY(dfi(i, j, :), em)
        fib = fib + dfib(i, j, :)
        fb(i, j, :) = fb(i, j, :) - dfib(i, j, :)
        dfib(i, j, :) = 0.0_8
        wi(:) = w(i, j, :) + dwi(i, j, :)
        rhom1 = one/wi(1)
        velyi = wi(3)*rhom1
        wib = 0.0_8
        velyib = SUM(wi(6:em)*gib(6:em))
        velxi = wi(2)*rhom1
        wib(6:em) = wib(6:em) + velyi*gib(6:em) + velxi*fib(6:em)
        gib(6:em) = 0.0_8
        velxib = SUM(wi(6:em)*fib(6:em))
        fib(6:em) = 0.0_8
        pintb = velyi*gib(5) + gib(3) + velxi*fib(5) + fib(2)
        velzi = wi(4)*rhom1
        temp3 = velxi*velxi + velyi*velyi + velzi*velzi
        gam1b = gam1b + (wi(5)-half*(wi(1)*temp3))*pintb
        tempb3 = gam1*pintb
        wib(5) = wib(5) + velyi*gib(5) + velxi*fib(5) + tempb3
        tempb2 = -(wi(1)*half*tempb3)
        velyib = velyib + (wi(5)+pint)*gib(5) + wi(3)*gib(3) + wi(2)*fib&
&         (3) + 2*velyi*tempb2
        gib(5) = 0.0_8
        wib(3) = wib(3) + velzi*gib(4) + velyi*gib(3) + velxi*gib(2) + &
&         gib(1) + rhom1*velyib
        velzib = wi(3)*gib(4) + wi(2)*fib(4) + 2*velzi*tempb2
        gib(4) = 0.0_8
        gib(3) = 0.0_8
        velxib = velxib + wi(3)*gib(2) + (wi(5)+pint)*fib(5) + wi(2)*fib&
&         (2) + 2*velxi*tempb2
        gib(2) = 0.0_8
        gib(1) = 0.0_8
        fib(5) = 0.0_8
        wib(2) = wib(2) + velzi*fib(4) + velyi*fib(3) + velxi*fib(2) + &
&         fib(1) + rhom1*velxib
        fib(4) = 0.0_8
        fib(3) = 0.0_8
        fib(2) = 0.0_8
        fib(1) = 0.0_8
        CALL POPREAL8(pint)
        wib(4) = wib(4) + rhom1*velzib
        rhom1b = wi(4)*velzib + wi(3)*velyib + wi(2)*velxib
        wib(1) = wib(1) - temp3*half*tempb3 - one*rhom1b/wi(1)**2
        wb(i, j, :) = wb(i, j, :) + wib
        dwib(i, j, :) = dwib(i, j, :) + wib
      END DO
    END DO
    DO equa=em,6,-1
      CALL POPREAL8ARRAY(dwi(1:im, 1:jm, equa), im*jm)
      temp4 = coefdiag(1:im, 1:jm, 2) + src_i(1:im, 1:jm)
      d2wb(1:im, 1:jm, equa) = d2wb(1:im, 1:jm, equa) + dwib(1:im, 1:jm&
&       , equa)/temp4
      tempb6 = -(d2w(1:im, 1:jm, equa)*dwib(1:im, 1:jm, equa)/temp4**2)
      dwib(1:im, 1:jm, equa) = 0.0_8
      coefdiagb(1:im, 1:jm, 2) = coefdiagb(1:im, 1:jm, 2) + tempb6
      src_ib(1:im, 1:jm) = src_ib(1:im, 1:jm) + tempb6
    END DO
    CALL POPREAL8ARRAY(dwi(1:im, 1:jm, 5), im*jm)
    d2wb(1:im, 1:jm, 5) = d2wb(1:im, 1:jm, 5) + dwib(1:im, 1:jm, 5)/&
&     coefdiag(1:im, 1:jm, 1)
    coefdiagb(1:im, 1:jm, 1) = coefdiagb(1:im, 1:jm, 1) - d2w(1:im, 1:jm&
&     , 5)*dwib(1:im, 1:jm, 5)/coefdiag(1:im, 1:jm, 1)**2 - d2w(1:im, 1:&
&     jm, 4)*dwib(1:im, 1:jm, 4)/coefdiag(1:im, 1:jm, 1)**2 - d2w(1:im, &
&     1:jm, 3)*dwib(1:im, 1:jm, 3)/coefdiag(1:im, 1:jm, 1)**2 - d2w(1:im&
&     , 1:jm, 2)*dwib(1:im, 1:jm, 2)/coefdiag(1:im, 1:jm, 1)**2 - d2w(1:&
&     im, 1:jm, 1)*dwib(1:im, 1:jm, 1)/coefdiag(1:im, 1:jm, 1)**2
    dwib(1:im, 1:jm, 5) = 0.0_8
    CALL POPREAL8ARRAY(dwi(1:im, 1:jm, 4), im*jm)
    d2wb(1:im, 1:jm, 4) = d2wb(1:im, 1:jm, 4) + dwib(1:im, 1:jm, 4)/&
&     coefdiag(1:im, 1:jm, 1)
    dwib(1:im, 1:jm, 4) = 0.0_8
    CALL POPREAL8ARRAY(dwi(1:im, 1:jm, 3), im*jm)
    d2wb(1:im, 1:jm, 3) = d2wb(1:im, 1:jm, 3) + dwib(1:im, 1:jm, 3)/&
&     coefdiag(1:im, 1:jm, 1)
    dwib(1:im, 1:jm, 3) = 0.0_8
    CALL POPREAL8ARRAY(dwi(1:im, 1:jm, 2), im*jm)
    d2wb(1:im, 1:jm, 2) = d2wb(1:im, 1:jm, 2) + dwib(1:im, 1:jm, 2)/&
&     coefdiag(1:im, 1:jm, 1)
    dwib(1:im, 1:jm, 2) = 0.0_8
    CALL POPREAL8ARRAY(dwi(1:im, 1:jm, 1), im*jm)
    d2wb(1:im, 1:jm, 1) = d2wb(1:im, 1:jm, 1) + dwib(1:im, 1:jm, 1)/&
&     coefdiag(1:im, 1:jm, 1)
    dwib(1:im, 1:jm, 1) = 0.0_8
    DO kdir=2,1,-1
      DO equa=em,6,-1
        DO j=jm,1,-1
          DO i=im,1,-1
            CALL POPREAL8(d2w(i, j, equa))
            hnb(i, j, equa) = hnb(i, j, equa) + d2wb(i, j, equa)
            hnb(i+i0, j+j0, equa) = hnb(i+i0, j+j0, equa) - d2wb(i, j, &
&             equa)
            coefb(i, j, 2, kdir) = coefb(i, j, 2, kdir) + dwi(i-i0, j-j0&
&             , equa)*d2wb(i, j, equa)
            dwib(i-i0, j-j0, equa) = dwib(i-i0, j-j0, equa) + coef(i, j&
&             , 2, kdir)*d2wb(i, j, equa)
            coefb(i+i0, j+j0, 2, kdir) = coefb(i+i0, j+j0, 2, kdir) + &
&             dwi(i+i0, j+j0, equa)*d2wb(i, j, equa)
            dwib(i+i0, j+j0, equa) = dwib(i+i0, j+j0, equa) + coef(i+i0&
&             , j+j0, 2, kdir)*d2wb(i, j, equa)
          END DO
        END DO
      END DO
      DO j=jm,1,-1
        DO i=im,1,-1
          CALL POPREAL8ARRAY(d2w(i, j, 1:5), 5)
          hnb(i, j, 1:5) = hnb(i, j, 1:5) + d2wb(i, j, 1:5)
          hnb(i+i0, j+j0, 1:5) = hnb(i+i0, j+j0, 1:5) - d2wb(i, j, 1:5)
          coefb(i, j, 1, kdir) = coefb(i, j, 1, kdir) + SUM(dwi(i-i0, j-&
&           j0, 1:5)*d2wb(i, j, 1:5))
          dwib(i-i0, j-j0, 1:5) = dwib(i-i0, j-j0, 1:5) + coef(i, j, 1, &
&           kdir)*d2wb(i, j, 1:5)
          coefb(i+i0, j+j0, 1, kdir) = coefb(i+i0, j+j0, 1, kdir) + SUM(&
&           dwi(i+i0, j+j0, 1:5)*d2wb(i, j, 1:5))
          dwib(i+i0, j+j0, 1:5) = dwib(i+i0, j+j0, 1:5) + coef(i+i0, j+&
&           j0, 1, kdir)*d2wb(i, j, 1:5)
        END DO
      END DO
      CALL POPINTEGER4(ad_to0)
      DO j=ad_to0,1,-1
        CALL POPINTEGER4(ad_to)
        DO i=ad_to,1,-1
          tempb4 = nx(i, j, kdir)*half*hnb(i, j, :)
          nxb(i, j, kdir) = nxb(i, j, kdir) + SUM((dfi(i-i0, j-j0, :)+&
&           dfi(i, j, :))*hnb(i, j, :))*half
          tempb5 = ny(i, j, kdir)*half*hnb(i, j, :)
          nyb(i, j, kdir) = nyb(i, j, kdir) + SUM((dgi(i-i0, j-j0, :)+&
&           dgi(i, j, :))*hnb(i, j, :))*half
          hnb(i, j, :) = 0.0_8
          dgib(i-i0, j-j0, :) = dgib(i-i0, j-j0, :) + tempb5
          dgib(i, j, :) = dgib(i, j, :) + tempb5
          dfib(i-i0, j-j0, :) = dfib(i-i0, j-j0, :) + tempb4
          dfib(i, j, :) = dfib(i, j, :) + tempb4
        END DO
      END DO
      CALL POPINTEGER4(j0)
      CALL POPINTEGER4(i0)
    END DO
    DO equa=em,1,-1
      CALL POPREAL8ARRAY(d2w(:, :, equa), (im+2)*(jm+2))
      dwb(0:im+1, 0:jm+1, equa) = dwb(0:im+1, 0:jm+1, equa) + vol(0:im+1&
&       , 0:jm+1)*d2wb(:, :, equa)
      volb(0:im+1, 0:jm+1) = volb(0:im+1, 0:jm+1) + dw(0:im+1, 0:jm+1, &
&       equa)*d2wb(:, :, equa)
      d2wb(:, :, equa) = 0.0_8
    END DO
  END DO
  sigmainvb = 0.0_8
  gamprb = 0.0_8
  tlocb = 0.0_8
  mub = 0.0_8
  DO kdir=2,1,-1
    DO j=jm,1,-1
      DO i=im,1,-1
        coefb(i, j, 2, kdir) = coefb(i, j, 2, kdir) + coefdiagb(i, j, 2)
        coefb(i+i0, j+j0, 2, kdir) = coefb(i+i0, j+j0, 2, kdir) + &
&         coefdiagb(i, j, 2)
        coefb(i, j, 1, kdir) = coefb(i, j, 1, kdir) + coefdiagb(i, j, 1)
        coefb(i+i0, j+j0, 1, kdir) = coefb(i+i0, j+j0, 1, kdir) + &
&         coefdiagb(i, j, 1)
      END DO
    END DO
    DO j=jm+1,1,-1
      DO i=im+1,1,-1
        cc = gam*rgaz*half*(tloc(i-i0, j-j0)+tloc(i, j))
        tempb2 = 0.5d0*coefb(i, j, 2, kdir)
        coefb(i, j, 2, kdir) = 0.0_8
        abs1b = tempb2
        IF (cc*norm .EQ. 0.0) THEN
          tempb3 = 0.0_8
        ELSE
          tempb3 = tempb2/(2.0*SQRT(cc*norm))
        END IF
        diffturb = two*tempb2
        ccb = norm*tempb3
        normb = cc*tempb3
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x3b = abs1b
        ELSE
          x3b = -abs1b
        END IF
        uub = nx(i, j, kdir)*x3b
        nxb(i, j, kdir) = nxb(i, j, kdir) + uu*x3b
        vvb = ny(i, j, kdir)*x3b
        nyb(i, j, kdir) = nyb(i, j, kdir) + vv*x3b
        temp3 = norm*iro
        volfb(i, j, kdir) = volfb(i, j, kdir) + mutot*sigmainv*temp3*&
&         diffturb
        tempb3 = volf(i, j, kdir)*diffturb
        mutotb = sigmainv*temp3*tempb3
        sigmainvb = sigmainvb + mutot*temp3*tempb3
        tempb2 = mutot*sigmainv*tempb3
        normb = normb + iro*tempb2
        irob = norm*tempb2
        tempb2 = half*mutotb
        mub(i-i0, j-j0) = mub(i-i0, j-j0) + tempb2
        mub(i, j) = mub(i, j) + tempb2
        wb(i-i0, j-j0, 6) = wb(i-i0, j-j0, 6) + tempb2
        wb(i, j, 6) = wb(i, j, 6) + tempb2
        mutot = half*gampr*(mu(i-i0, j-j0)+mu(i, j))
        tempb2 = 0.5d0*coefb(i, j, 1, kdir)
        coefb(i, j, 1, kdir) = 0.0_8
        abs0b = tempb2
        IF (cc*norm .EQ. 0.0) THEN
          tempb3 = 0.0_8
        ELSE
          tempb3 = tempb2/(2.0*SQRT(cc*norm))
        END IF
        specdiffb = two*tempb2
        ccb = ccb + norm*tempb3
        normb = normb + cc*tempb3
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x2b = abs0b
        ELSE
          x2b = -abs0b
        END IF
        tempb2 = volf(i, j, kdir)*specdiffb
        normb = normb + mutot*iro*tempb2
        uub = uub + nx(i, j, kdir)*x2b
        nxb(i, j, kdir) = nxb(i, j, kdir) + uu*x2b + 2*nx(i, j, kdir)*&
&         normb
        vvb = vvb + ny(i, j, kdir)*x2b
        nyb(i, j, kdir) = nyb(i, j, kdir) + vv*x2b + 2*ny(i, j, kdir)*&
&         normb
        volfb(i, j, kdir) = volfb(i, j, kdir) + mutot*norm*iro*specdiffb
        mutotb = norm*iro*tempb2
        irob = irob + mutot*norm*tempb2
        CALL POPREAL8(mutot)
        tempb2 = half*mutotb
        gamprb = gamprb + (mu(i-i0, j-j0)+mu(i, j))*tempb2
        mub(i-i0, j-j0) = mub(i-i0, j-j0) + gampr*tempb2
        mub(i, j) = mub(i, j) + gampr*tempb2
        CALL POPREAL8(norm)
        tempb2 = (tloc(i-i0, j-j0)+tloc(i, j))*half*ccb
        tempb3 = gam*rgaz*half*ccb
        tlocb(i-i0, j-j0) = tlocb(i-i0, j-j0) + tempb3
        tlocb(i, j) = tlocb(i, j) + tempb3
        gamb = gamb + rgaz*tempb2
        rgazb = rgazb + gam*tempb2
        CALL POPREAL8(vv)
        tempb2 = half*vvb
        wb(i-i0, j-j0, 3) = wb(i-i0, j-j0, 3) + rom1l*tempb2
        rom1lb = w(i-i0, j-j0, 3)*tempb2
        wb(i, j, 3) = wb(i, j, 3) + rom1r*tempb2
        rom1rb = w(i, j, 3)*tempb2
        CALL POPREAL8(uu)
        tempb2 = half*uub
        wb(i-i0, j-j0, 2) = wb(i-i0, j-j0, 2) + rom1l*tempb2
        rom1lb = rom1lb + w(i-i0, j-j0, 2)*tempb2
        wb(i, j, 2) = wb(i, j, 2) + rom1r*tempb2
        rom1rb = rom1rb + w(i, j, 2)*tempb2
        CALL POPREAL8(iro)
        tempb2 = -(2.d0*irob/(rol+ror)**2)
        rolb = tempb2 - one*rom1lb/rol**2
        rorb = tempb2 - one*rom1rb/ror**2
        CALL POPREAL8(rom1r)
        CALL POPREAL8(rom1l)
        CALL POPREAL8(ror)
        wb(i, j, 1) = wb(i, j, 1) + rorb
        CALL POPREAL8(rol)
        wb(i-i0, j-j0, 1) = wb(i-i0, j-j0, 1) + rolb
      END DO
    END DO
    j0 = ad_save0(kdir)
    i0 = ad_save(kdir)
  END DO
  cvm1b = 0.0_8
  betasb = 0.0_8
  cflm1b = 0.0_8
  DO j=jm+gh,1-gh,-1
    DO i=im+gh,1-gh,-1
      dtm1 = cflm1/max1
      tempb2 = SUM(vol(1:im, 1:jm)*coefdiagb(1:im, 1:jm, 2))
      volb(1:im, 1:jm) = volb(1:im, 1:jm) + dtcoef*dtm1*coefdiagb(1:im, &
&       1:jm, 2) + dtcoef*dtm1*coefdiagb(1:im, 1:jm, 1)
      coefdiagb(1:im, 1:jm, 2) = 0.0_8
      dtcoefb = dtcoefb + dtm1*tempb2
      dtm1b = dtcoef*tempb2
      tempb2 = SUM(vol(1:im, 1:jm)*coefdiagb(1:im, 1:jm, 1))
      coefdiagb(1:im, 1:jm, 1) = 0.0_8
      dtcoefb = dtcoefb + dtm1*tempb2
      dtm1b = dtm1b + dtcoef*tempb2
      cflm1b = cflm1b + dtm1b/max1
      max1b = -(cflm1*dtm1b/max1**2)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(max1)
        x1b = 0.0_8
      ELSE
        CALL POPREAL8(max1)
        x1b = max1b
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        dt_nsb = x1b
        dt_eulerb = 0.0_8
      ELSE
        dt_eulerb = x1b
        dt_nsb = 0.0_8
      END IF
      temp3 = gampr*mu(i, j)
      tempb3 = half*dt_nsb/temp3
      distb = 2*dist*ror*tempb3 + dt_eulerb/vitc
      rorb = dist**2*tempb3
      tempb2 = -(dist**2*ror*tempb3/temp3)
      gamprb = gamprb + mu(i, j)*tempb2
      mub(i, j) = mub(i, j) + gampr*tempb2
      vitcb = -(dist*dt_eulerb/vitc**2)
      rom1 = one/ror
      velyi = w(i, j, 3)*rom1
      velxi = w(i, j, 2)*rom1
      CALL POPREAL8(vitc)
      IF (velxi**2 + velyi**2 .EQ. 0.0) THEN
        tempb2 = 0.0_8
      ELSE
        tempb2 = vitcb/(2.0*SQRT(velxi**2+velyi**2))
      END IF
      ccb = vitcb
      velxib = 2*velxi*tempb2
      velyib = 2*velyi*tempb2
      pint = ror*rgaz*tloc(i, j)
      IF (gam*pint*rom1 .EQ. 0.0) THEN
        tempb2 = 0.0_8
      ELSE
        tempb2 = ccb/(2.0*SQRT(gam*pint*rom1))
      END IF
      gamb = gamb + pint*rom1*tempb2
      pintb = gam*rom1*tempb2
      rom1b = gam*pint*tempb2
      CALL POPREAL8(dist)
      temp1 = nx(i, j, 2)*nx(i, j, 2) + ny(i, j, 2)*ny(i, j, 2)
      temp0 = SQRT(temp1)
      temp = nx(i, j, 1)*nx(i, j, 1) + ny(i, j, 1)*ny(i, j, 1)
      temp2 = SQRT(temp)
      temp3 = temp2 + temp0
      volb(i, j) = volb(i, j) + distb/temp3
      tempb2 = -(vol(i, j)*distb/temp3**2)
      IF (.NOT.temp .EQ. 0.0) nxb(i, j, 1) = nxb(i, j, 1) + 2*nx(i, j, 1&
&         )*tempb2/(2.0*temp2)
      IF (.NOT.temp .EQ. 0.0) nyb(i, j, 1) = nyb(i, j, 1) + 2*ny(i, j, 1&
&         )*tempb2/(2.0*temp2)
      IF (.NOT.temp1 .EQ. 0.0) nxb(i, j, 2) = nxb(i, j, 2) + 2*nx(i, j, &
&         2)*tempb2/(2.0*temp0)
      IF (.NOT.temp1 .EQ. 0.0) nyb(i, j, 2) = nyb(i, j, 2) + 2*ny(i, j, &
&         2)*tempb2/(2.0*temp0)
      DO itur=em,6,-1
        tempb1 = w(i, j, itur)*gb(i, j, itur)
        wb(i, j, itur) = wb(i, j, itur) + w(i, j, 3)*rom1*gb(i, j, itur)
        gb(i, j, itur) = 0.0_8
        wb(i, j, 3) = wb(i, j, 3) + rom1*tempb1
        rom1b = rom1b + w(i, j, 3)*tempb1
        tempb1 = w(i, j, itur)*fb(i, j, itur)
        wb(i, j, itur) = wb(i, j, itur) + w(i, j, 2)*rom1*fb(i, j, itur)
        fb(i, j, itur) = 0.0_8
        wb(i, j, 2) = wb(i, j, 2) + rom1*tempb1
        rom1b = rom1b + w(i, j, 2)*tempb1
      END DO
      htotb = w(i, j, 3)*gb(i, j, 5) + w(i, j, 2)*fb(i, j, 5)
      pintb = pintb + gb(i, j, 3) + fb(i, j, 2) + rom1*htotb
      temp1 = betas*tloc(i, j)/(tloc(i, j)+s_suth)
      temp0 = SQRT(tloc(i, j))
      tempb1 = temp0*mub(i, j)/(tloc(i, j)+s_suth)
      betasb = betasb + tloc(i, j)*tempb1
      tempb = -(temp1*tempb1)
      IF (tloc(i, j) .EQ. 0.0) THEN
        tlocb(i, j) = tlocb(i, j) + betas*tempb1 + tempb + ror*rgaz*&
&         pintb
      ELSE
        tlocb(i, j) = tlocb(i, j) + temp1*mub(i, j)/(2.0*temp0) + betas*&
&         tempb1 + tempb + ror*rgaz*pintb
      END IF
      mub(i, j) = 0.0_8
      s_suthb = s_suthb + tempb
      htot = (w(i, j, 5)+pint)*rom1
      velzi = w(i, j, 4)*rom1
      tempb1 = tloc(i, j)*pintb
      rorb = rorb + rgaz*tempb1
      rgazb = rgazb + ror*tempb1
      ec = half*(velxi*velxi+velyi*velyi+velzi*velzi)
      eloc = (w(i, j, 5)-ec*ror)*rom1
      elocb = cvm1*tlocb(i, j)
      cvm1b = cvm1b + eloc*tlocb(i, j)
      tlocb(i, j) = 0.0_8
      tempb1 = rom1*elocb
      wb(i, j, 5) = wb(i, j, 5) + rom1*htotb + tempb1
      ecb = -(ror*tempb1)
      rorb = rorb - ec*tempb1
      tempb1 = half*ecb
      velzib = w(i, j, 3)*gb(i, j, 4) + w(i, j, 2)*fb(i, j, 4) + 2*velzi&
&       *tempb1
      velyib = velyib + w(i, j, 3)*gb(i, j, 3) + w(i, j, 2)*fb(i, j, 3) &
&       + 2*velyi*tempb1
      wb(i, j, 3) = wb(i, j, 3) + htot*gb(i, j, 5) + velzi*gb(i, j, 4) +&
&       velyi*gb(i, j, 3) + velxi*gb(i, j, 2) + gb(i, j, 1) + rom1*&
&       velyib
      gb(i, j, 5) = 0.0_8
      gb(i, j, 4) = 0.0_8
      gb(i, j, 3) = 0.0_8
      velxib = velxib + w(i, j, 3)*gb(i, j, 2) + w(i, j, 2)*fb(i, j, 2) &
&       + 2*velxi*tempb1
      gb(i, j, 2) = 0.0_8
      gb(i, j, 1) = 0.0_8
      wb(i, j, 2) = wb(i, j, 2) + htot*fb(i, j, 5) + velzi*fb(i, j, 4) +&
&       velyi*fb(i, j, 3) + velxi*fb(i, j, 2) + fb(i, j, 1) + rom1*&
&       velxib
      fb(i, j, 5) = 0.0_8
      fb(i, j, 4) = 0.0_8
      fb(i, j, 3) = 0.0_8
      fb(i, j, 2) = 0.0_8
      fb(i, j, 1) = 0.0_8
      rom1b = rom1b + (w(i, j, 5)+pint)*htotb + (w(i, j, 5)-ec*ror)*&
&       elocb + w(i, j, 4)*velzib + w(i, j, 3)*velyib + w(i, j, 2)*&
&       velxib
      wb(i, j, 4) = wb(i, j, 4) + rom1*velzib
      rorb = rorb - one*rom1b/ror**2
      CALL POPREAL8(ror)
      wb(i, j, 1) = wb(i, j, 1) + rorb
    END DO
  END DO
  tempb = 2.d0*gamprb/prandtl
  sigmab = sigmab - one*sigmainvb/sigma**2
  temp = SQRT(tref)
  tempb0 = betasb/(temp*tref)
  murefb = murefb + (tref+cs)*tempb0
  csb = csb + muref*tempb0
  tempb1 = -(muref*(tref+cs)*tempb0/(temp*tref))
  IF (tref .EQ. 0.0) THEN
    trefb = trefb + muref*tempb0 + temp*tempb1
  ELSE
    trefb = trefb + muref*tempb0 + (tref/(2.0*temp)+temp)*tempb1
  END IF
  cvb = cvb - one*cvm1b/cv**2
  cflb = cflb - one*cflm1b/cfl**2
  gamb = gamb + gam1b + tempb
  prandtlb = prandtlb - gam*tempb/prandtl
  dwib = 0.0_8
END SUBROUTINE IMPLI_MATRIX_FREE_RANS_2D_B
!

