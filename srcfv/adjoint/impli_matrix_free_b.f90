! This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of impli_matrix_free_2d in reverse (adjoint) mode (with options with!SliceDeadControl with!SliceDeadInstrs wit
!h!StaticTaping):
!   gradient     of useful results: w dwi
!   with respect to varying inputs: w dwi
!   RW status of diff variables: w:incr dwi:in-zero
! =============================================================================
!                Implicit matrix free phase 2D NS
! =============================================================================
SUBROUTINE IMPLI_MATRIX_FREE_2D_B(dwi, dwib, nx, ny, w, wb, dw, vol, &
& volf, dtcoef, cfl, gam, rgaz, prandtl, lmax, gh, cv, cs, muref, tref, &
& s_suth, im, jm, em)
  IMPLICIT NONE
!
!
! variables for dimension -----------------------------------------
  INTEGER, INTENT(IN) :: em, im, jm, lmax
  INTEGER, INTENT(IN) :: gh
! required arguments ----------------------------------------------
  REAL*8, INTENT(IN) :: dtcoef, gam, rgaz, prandtl, cfl, cs, muref, tref&
& , s_suth, cv
  REAL*8, DIMENSION(1-gh:im+1+gh, 1-gh:jm+1+gh, 2), INTENT(IN) :: nx, ny
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2), INTENT(IN) :: volf
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: vol
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(IN) :: w
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em) :: wb
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(IN) :: dw
! Returned objects ------------------------------------------------
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(INOUT) :: dwi
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(INOUT) :: dwib
! Local variables -------------------------------------------------
  INTEGER :: i, j, l, equa, kdir, i0, j0, ipt, le, eq2
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: tloc, mu
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: tlocb, mub
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em) :: d2w, dfi, dgi, hn, f&
& , g
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em) :: d2wb, dfib, dgib, hnb&
& , fb, gb
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: coefdiag
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: coefdiagb
!specrad
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2) :: coef
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2) :: coefb
  REAL*8, DIMENSION(em) :: wi, fi, gi
  REAL*8, DIMENSION(em) :: wib, fib, gib
  REAL*8 :: velxi, velyi, velzi, pint, tint, htot
  REAL*8 :: velxib, velyib, velzib, pintb, htotb
  REAL*8 :: rhom1, roki, norm, specdiff, iro, rol, ror, rom1
  REAL*8 :: rhom1b, specdiffb, irob, rolb, rorb, rom1b
  REAL*8 :: one, half, zero, two, rom1l, rom1r, gampr, gamprt
  REAL*8 :: rom1lb, rom1rb
  REAL*8 :: uu, vv, cc, gam1, mutot
  REAL*8 :: uub, vvb, ccb, mutotb
  REAL*8 :: dtm1, dist, vitc, dt_euler, dt_ns, cvm1
  REAL*8 :: dtm1b, vitcb, dt_eulerb, dt_nsb
  REAL*8 :: ec, eloc, betas, diagm1, cflm1, dtm1save
  REAL*8 :: ecb, elocb, diagm1b
  INTRINSIC SQRT
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC ABS
  REAL*8 :: x1
  REAL*8 :: x1b
  REAL*8 :: x2
  REAL*8 :: x2b
  REAL*8 :: max1
  REAL*8 :: max1b
  REAL*8 :: abs0
  REAL*8 :: abs0b
  REAL*8 :: temp
  REAL*8 :: tempb
  REAL*8 :: temp0
  REAL*8 :: tempb0
  INTEGER, DIMENSION(2) :: ad_save
  INTEGER, DIMENSION(2) :: ad_save0
  REAL*8, DIMENSION(em) :: tempb1
  REAL*8, DIMENSION(em) :: tempb2
  INTEGER :: branch
  INTEGER :: ad_to
  INTEGER :: ad_to0
  INTEGER, DIMENSION(2) :: ad_save1
  INTEGER :: ad_to1
  INTEGER :: ad_to2
! -----------------------------------------------------------------
  half = 0.5d0
  zero = 0.d0
  two = 2.d0
  one = 1.d0
!
  dwi = zero
  dfi = zero
  dgi = zero
!
  gampr = 2.d0*gam/prandtl
  gam1 = gam - one
!
  cflm1 = one/cfl
  cvm1 = one/cv
  betas = muref*(tref+cs)/(SQRT(tref)*tref)
  DO j=1-gh,jm+gh
    DO i=1-gh,im+gh
      CALL PUSHREAL8(ror)
      ror = w(i, j, 1)
      CALL PUSHREAL8(rom1)
      rom1 = one/ror
      CALL PUSHREAL8(velxi)
      velxi = w(i, j, 2)*rom1
      CALL PUSHREAL8(velyi)
      velyi = w(i, j, 3)*rom1
      CALL PUSHREAL8(velzi)
      velzi = w(i, j, 4)*rom1
!
      CALL PUSHREAL8(ec)
      ec = half*(velxi*velxi+velyi*velyi+velzi*velzi)
!
      eloc = (w(i, j, 5)-ec*ror)*rom1
!
      tloc(i, j) = eloc*cvm1
!
      pint = ror*rgaz*tloc(i, j)
      htot = (w(i, j, 5)+pint)*rom1
      f(i, j, 1) = w(i, j, 2)
      f(i, j, 2) = w(i, j, 2)*velxi + pint
      f(i, j, 3) = w(i, j, 2)*velyi
      f(i, j, 4) = w(i, j, 2)*velzi
      f(i, j, 5) = w(i, j, 2)*htot
      g(i, j, 1) = w(i, j, 3)
      g(i, j, 2) = w(i, j, 3)*velxi
      g(i, j, 3) = w(i, j, 3)*velyi + pint
      g(i, j, 4) = w(i, j, 3)*velzi
      g(i, j, 5) = w(i, j, 3)*htot
!h(i,j,1)  = w(i,j,4)
!h(i,j,2)  = w(i,j,4) * velx(i,j)
!h(i,j,3)  = w(i,j,4) * vely(i,j)
!h(i,j,4)  = w(i,j,4) * velz(i,j) + pint
!h(i,j,5)  = w(i,j,4) * htot
      mu(i, j) = betas/(tloc(i, j)+s_suth)*SQRT(tloc(i, j))*tloc(i, j)
      CALL PUSHREAL8(dist)
      dist = vol(i, j)/(SQRT(nx(i, j, 1)*nx(i, j, 1)+ny(i, j, 1)*ny(i, j&
&       , 1))+SQRT(nx(i, j, 2)*nx(i, j, 2)+ny(i, j, 2)*ny(i, j, 2)))
      cc = SQRT(gam*pint*rom1)
      CALL PUSHREAL8(vitc)
      vitc = SQRT(velxi*velxi + velyi*velyi) + cc
      dt_euler = dist/vitc
      dt_ns = half*dist*dist*ror/(gampr*mu(i, j))
      IF (dt_euler .GT. dt_ns) THEN
        x1 = dt_ns
        CALL PUSHCONTROL1B(0)
      ELSE
        x1 = dt_euler
        CALL PUSHCONTROL1B(1)
      END IF
      IF (x1 .LT. 1.d-15) THEN
        CALL PUSHREAL8(max1)
        max1 = 1.d-15
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8(max1)
        max1 = x1
        CALL PUSHCONTROL1B(1)
      END IF
! 1/dt
      dtm1 = cflm1/max1
!write(30101,*) "i,j    =  ", i,j
!write(30101,*) "dtm1   =  ", dtm1
!write(30101,*) "distm1 =  ", distm1
!write(30101,*) "cflm1  =  ", dtm1
!write(30101,*) "mu     =  ", mu(i,j)
! compute diagonal coefficient------------------------------------------------------
! dtcoef/tau0
      coefdiag(i, j) = dtm1*dtcoef*vol(i, j)
    END DO
  END DO
!   !for global timeStep
!   dtm1save = 1.d-15
!   do j = 1 , jm
!   do i = 1 , im
! #include "lhs/PrimitivesLhs.F"
! #include "phys/viscosity.F"
! #include "lhs/time_step.F"
!     IF (dtm1.gt.dtm1save) THEN
!       dtm1save = dtm1
!     ENDIF
!     dtm1 = dtm1save
!   enddo
!   enddo
!     !
!   coefdiag(1:im,1:jm) = dtm1 * dtcoef * vol(1:im,1:jm) ! dtcoef/tau0
!
loop_kdir:DO kdir=1,2
    ad_save(kdir) = i0
    i0 = -kdir + 2
    ad_save0(kdir) = j0
    j0 = kdir - 1
!
    DO j=1,jm+j0
      DO i=1,im+i0
        CALL PUSHREAL8(rol)
        rol = w(i-i0, j-j0, 1)
        CALL PUSHREAL8(ror)
        ror = w(i, j, 1)
        CALL PUSHREAL8(rom1l)
        rom1l = one/rol
        CALL PUSHREAL8(rom1r)
        rom1r = one/ror
        CALL PUSHREAL8(iro)
        iro = 2.d0/(rol+ror)
        uu = half*(w(i-i0, j-j0, 2)*rom1l+w(i, j, 2)*rom1r)
        vv = half*(w(i-i0, j-j0, 3)*rom1l+w(i, j, 3)*rom1r)
        cc = gam*rgaz*half*(tloc(i-i0, j-j0)+tloc(i, j))
        CALL PUSHREAL8(norm)
        norm = nx(i, j, kdir)*nx(i, j, kdir) + ny(i, j, kdir)*ny(i, j, &
&         kdir)
        CALL PUSHREAL8(mutot)
        mutot = half*gampr*(mu(i-i0, j-j0)+mu(i, j))
        specdiff = mutot*norm*volf(i, j, kdir)*iro
        x2 = uu*nx(i, j, kdir) + vv*ny(i, j, kdir)
        IF (x2 .GE. 0.) THEN
          abs0 = x2
          CALL PUSHCONTROL1B(0)
        ELSE
          abs0 = -x2
          CALL PUSHCONTROL1B(1)
        END IF
        coef(i, j, kdir) = one*(abs0+SQRT(cc*norm)+two*specdiff)
      END DO
      CALL PUSHINTEGER4(i - 1)
    END DO
    ad_save1(kdir) = j - 1
    DO j=1,jm
      DO i=1,im
        coefdiag(i, j) = coefdiag(i, j) + coef(i, j, kdir) + coef(i+i0, &
&         j+j0, kdir)
      END DO
    END DO
  END DO loop_kdir
loop_subite:DO l=1,lmax
    CALL PUSHREAL8ARRAY(d2w, (im+2*gh)*(jm+2*gh)*em)
    d2w = dw
!
! Computation of the left hand side
!
loop_kdir_inner:DO kdir=1,2
      CALL PUSHINTEGER4(i0)
      i0 = -kdir + 2
      CALL PUSHINTEGER4(j0)
      j0 = kdir - 1
!
      DO j=1,jm+j0
        DO i=1,im+i0
!norm = dsqrt( nx(i,j,kdir)**2 + ny(i,j,kdir)**2)
          hn(i, j, :) = half*(dfi(i-i0, j-j0, :)+dfi(i, j, :))*nx(i, j, &
&           kdir) + half*(dgi(i-i0, j-j0, :)+dgi(i, j, :))*ny(i, j, kdir&
&           )
        END DO
        CALL PUSHINTEGER4(i - 1)
      END DO
      CALL PUSHINTEGER4(j - 1)
!
      DO j=1,jm
        DO i=1,im
          d2w(i, j, :) = d2w(i, j, :) + hn(i, j, :) - hn(i+i0, j+j0, :) &
&           + coef(i, j, kdir)*dwi(i-i0, j-j0, :) + coef(i+i0, j+j0, &
&           kdir)*dwi(i+i0, j+j0, :)
        END DO
      END DO
    END DO loop_kdir_inner
!
! Computation of the intermediate increment
!
    DO j=1,jm
      DO i=1,im
        diagm1 = one/coefdiag(i, j)
        CALL PUSHREAL8(dwi(i, j, 1))
        dwi(i, j, 1) = d2w(i, j, 1)*diagm1
        CALL PUSHREAL8(dwi(i, j, 2))
        dwi(i, j, 2) = d2w(i, j, 2)*diagm1
        CALL PUSHREAL8(dwi(i, j, 3))
        dwi(i, j, 3) = d2w(i, j, 3)*diagm1
        CALL PUSHREAL8(dwi(i, j, 4))
        dwi(i, j, 4) = d2w(i, j, 4)*diagm1
        CALL PUSHREAL8(dwi(i, j, 5))
        dwi(i, j, 5) = d2w(i, j, 5)*diagm1
      END DO
    END DO
!
! Actualisation de wi
!
    DO j=1,jm
      DO i=1,im
        wi(:) = w(i, j, :) + dwi(i, j, :)
        rhom1 = one/wi(1)
        CALL PUSHREAL8(velxi)
        velxi = wi(2)*rhom1
        CALL PUSHREAL8(velyi)
        velyi = wi(3)*rhom1
        CALL PUSHREAL8(velzi)
        velzi = wi(4)*rhom1
        CALL PUSHREAL8(pint)
        pint = gam1*(wi(5)-half*wi(1)*(velxi*velxi+velyi*velyi+velzi*&
&         velzi))
!
! Actualisation des flux intermediaires
!
        fi(1) = wi(2)
        fi(2) = wi(2)*velxi + pint
        fi(3) = wi(2)*velyi
        fi(4) = wi(2)*velzi
        fi(5) = velxi*(wi(5)+pint)
        gi(1) = wi(3)
        gi(2) = wi(3)*velxi
        gi(3) = wi(3)*velyi + pint
        gi(4) = wi(3)*velzi
        gi(5) = velyi*(wi(5)+pint)
!
! Calcul des increments des flux
!
        dfi(i, j, :) = fi(:) - f(i, j, :)
        dgi(i, j, :) = gi(:) - g(i, j, :)
      END DO
    END DO
  END DO loop_subite
  fb = 0.0_8
  gb = 0.0_8
  coefb = 0.0_8
  coefdiagb = 0.0_8
  hnb = 0.0_8
  fib = 0.0_8
  dfib = 0.0_8
  gib = 0.0_8
  dgib = 0.0_8
  DO l=lmax,1,-1
    DO j=jm,1,-1
      DO i=im,1,-1
        gib = gib + dgib(i, j, :)
        gb(i, j, :) = gb(i, j, :) - dgib(i, j, :)
        dgib(i, j, :) = 0.0_8
        fib = fib + dfib(i, j, :)
        fb(i, j, :) = fb(i, j, :) - dfib(i, j, :)
        dfib(i, j, :) = 0.0_8
        wi(:) = w(i, j, :) + dwi(i, j, :)
        rhom1 = one/wi(1)
        velyi = wi(3)*rhom1
        wib = 0.0_8
        velzi = wi(4)*rhom1
        velxi = wi(2)*rhom1
        pintb = velyi*gib(5) + gib(3) + velxi*fib(5) + fib(2)
        tempb0 = gam1*pintb
        wib(5) = wib(5) + velyi*gib(5) + velxi*fib(5) + tempb0
        tempb = -(wi(1)*half*tempb0)
        velyib = (wi(5)+pint)*gib(5) + wi(3)*gib(3) + wi(2)*fib(3) + 2*&
&         velyi*tempb
        gib(5) = 0.0_8
        wib(3) = wib(3) + velzi*gib(4) + velyi*gib(3) + velxi*gib(2) + &
&         gib(1) + rhom1*velyib
        velzib = wi(3)*gib(4) + wi(2)*fib(4) + 2*velzi*tempb
        gib(4) = 0.0_8
        gib(3) = 0.0_8
        velxib = wi(3)*gib(2) + (wi(5)+pint)*fib(5) + wi(2)*fib(2) + 2*&
&         velxi*tempb
        gib(2) = 0.0_8
        gib(1) = 0.0_8
        fib(5) = 0.0_8
        wib(2) = wib(2) + velzi*fib(4) + velyi*fib(3) + velxi*fib(2) + &
&         fib(1) + rhom1*velxib
        fib(4) = 0.0_8
        fib(3) = 0.0_8
        fib(2) = 0.0_8
        fib(1) = 0.0_8
        CALL POPREAL8(pint)
        wib(4) = wib(4) + rhom1*velzib
        rhom1b = wi(4)*velzib + wi(3)*velyib + wi(2)*velxib
        wib(1) = wib(1) - (velxi**2+velyi**2+velzi**2)*half*tempb0 - one&
&         *rhom1b/wi(1)**2
        CALL POPREAL8(velzi)
        CALL POPREAL8(velyi)
        CALL POPREAL8(velxi)
        wb(i, j, :) = wb(i, j, :) + wib
        dwib(i, j, :) = dwib(i, j, :) + wib
      END DO
    END DO
    d2wb = 0.0_8
    DO j=jm,1,-1
      DO i=im,1,-1
        diagm1 = one/coefdiag(i, j)
        CALL POPREAL8(dwi(i, j, 5))
        d2wb(i, j, 5) = d2wb(i, j, 5) + diagm1*dwib(i, j, 5)
        diagm1b = d2w(i, j, 5)*dwib(i, j, 5) + d2w(i, j, 4)*dwib(i, j, 4&
&         ) + d2w(i, j, 3)*dwib(i, j, 3) + d2w(i, j, 2)*dwib(i, j, 2) + &
&         d2w(i, j, 1)*dwib(i, j, 1)
        dwib(i, j, 5) = 0.0_8
        CALL POPREAL8(dwi(i, j, 4))
        d2wb(i, j, 4) = d2wb(i, j, 4) + diagm1*dwib(i, j, 4)
        dwib(i, j, 4) = 0.0_8
        CALL POPREAL8(dwi(i, j, 3))
        d2wb(i, j, 3) = d2wb(i, j, 3) + diagm1*dwib(i, j, 3)
        dwib(i, j, 3) = 0.0_8
        CALL POPREAL8(dwi(i, j, 2))
        d2wb(i, j, 2) = d2wb(i, j, 2) + diagm1*dwib(i, j, 2)
        dwib(i, j, 2) = 0.0_8
        CALL POPREAL8(dwi(i, j, 1))
        d2wb(i, j, 1) = d2wb(i, j, 1) + diagm1*dwib(i, j, 1)
        dwib(i, j, 1) = 0.0_8
        coefdiagb(i, j) = coefdiagb(i, j) - one*diagm1b/coefdiag(i, j)**&
&         2
      END DO
    END DO
    DO kdir=2,1,-1
      DO j=jm,1,-1
        DO i=im,1,-1
          hnb(i, j, :) = hnb(i, j, :) + d2wb(i, j, :)
          hnb(i+i0, j+j0, :) = hnb(i+i0, j+j0, :) - d2wb(i, j, :)
          coefb(i, j, kdir) = coefb(i, j, kdir) + SUM(dwi(i-i0, j-j0, :)&
&           *d2wb(i, j, :))
          dwib(i-i0, j-j0, :) = dwib(i-i0, j-j0, :) + coef(i, j, kdir)*&
&           d2wb(i, j, :)
          coefb(i+i0, j+j0, kdir) = coefb(i+i0, j+j0, kdir) + SUM(dwi(i+&
&           i0, j+j0, :)*d2wb(i, j, :))
          dwib(i+i0, j+j0, :) = dwib(i+i0, j+j0, :) + coef(i+i0, j+j0, &
&           kdir)*d2wb(i, j, :)
        END DO
      END DO
      CALL POPINTEGER4(ad_to2)
      DO j=ad_to2,1,-1
        CALL POPINTEGER4(ad_to1)
        DO i=ad_to1,1,-1
          tempb1 = half*nx(i, j, kdir)*hnb(i, j, :)
          tempb2 = half*ny(i, j, kdir)*hnb(i, j, :)
          hnb(i, j, :) = 0.0_8
          dgib(i-i0, j-j0, :) = dgib(i-i0, j-j0, :) + tempb2
          dgib(i, j, :) = dgib(i, j, :) + tempb2
          dfib(i-i0, j-j0, :) = dfib(i-i0, j-j0, :) + tempb1
          dfib(i, j, :) = dfib(i, j, :) + tempb1
        END DO
      END DO
      CALL POPINTEGER4(j0)
      CALL POPINTEGER4(i0)
    END DO
    CALL POPREAL8ARRAY(d2w, (im+2*gh)*(jm+2*gh)*em)
  END DO
  tlocb = 0.0_8
  mub = 0.0_8
  DO kdir=2,1,-1
    DO j=jm,1,-1
      DO i=im,1,-1
        coefb(i, j, kdir) = coefb(i, j, kdir) + coefdiagb(i, j)
        coefb(i+i0, j+j0, kdir) = coefb(i+i0, j+j0, kdir) + coefdiagb(i&
&         , j)
      END DO
    END DO
    ad_to0 = ad_save1(kdir)
    DO j=ad_to0,1,-1
      CALL POPINTEGER4(ad_to)
      DO i=ad_to,1,-1
        cc = gam*rgaz*half*(tloc(i-i0, j-j0)+tloc(i, j))
        tempb0 = one*coefb(i, j, kdir)
        coefb(i, j, kdir) = 0.0_8
        abs0b = tempb0
        IF (norm*cc .EQ. 0.0) THEN
          ccb = 0.0_8
        ELSE
          ccb = norm*tempb0/(2.0*SQRT(norm*cc))
        END IF
        specdiffb = two*tempb0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x2b = abs0b
        ELSE
          x2b = -abs0b
        END IF
        uub = nx(i, j, kdir)*x2b
        vvb = ny(i, j, kdir)*x2b
        tempb0 = norm*volf(i, j, kdir)*specdiffb
        mutotb = iro*tempb0
        irob = mutot*tempb0
        CALL POPREAL8(mutot)
        tempb0 = half*gampr*mutotb
        mub(i-i0, j-j0) = mub(i-i0, j-j0) + tempb0
        mub(i, j) = mub(i, j) + tempb0
        CALL POPREAL8(norm)
        tempb0 = gam*rgaz*half*ccb
        tlocb(i-i0, j-j0) = tlocb(i-i0, j-j0) + tempb0
        tlocb(i, j) = tlocb(i, j) + tempb0
        tempb0 = half*vvb
        wb(i-i0, j-j0, 3) = wb(i-i0, j-j0, 3) + rom1l*tempb0
        rom1lb = w(i-i0, j-j0, 3)*tempb0
        wb(i, j, 3) = wb(i, j, 3) + rom1r*tempb0
        rom1rb = w(i, j, 3)*tempb0
        tempb0 = half*uub
        wb(i-i0, j-j0, 2) = wb(i-i0, j-j0, 2) + rom1l*tempb0
        rom1lb = rom1lb + w(i-i0, j-j0, 2)*tempb0
        wb(i, j, 2) = wb(i, j, 2) + rom1r*tempb0
        rom1rb = rom1rb + w(i, j, 2)*tempb0
        CALL POPREAL8(iro)
        tempb0 = -(2.d0*irob/(rol+ror)**2)
        rolb = tempb0 - one*rom1lb/rol**2
        rorb = tempb0 - one*rom1rb/ror**2
        CALL POPREAL8(rom1r)
        CALL POPREAL8(rom1l)
        CALL POPREAL8(ror)
        wb(i, j, 1) = wb(i, j, 1) + rorb
        CALL POPREAL8(rol)
        wb(i-i0, j-j0, 1) = wb(i-i0, j-j0, 1) + rolb
      END DO
    END DO
    j0 = ad_save0(kdir)
    i0 = ad_save(kdir)
  END DO
  DO j=jm+gh,1-gh,-1
    DO i=im+gh,1-gh,-1
      dtm1b = dtcoef*vol(i, j)*coefdiagb(i, j)
      coefdiagb(i, j) = 0.0_8
      max1b = -(cflm1*dtm1b/max1**2)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(max1)
        x1b = 0.0_8
      ELSE
        CALL POPREAL8(max1)
        x1b = max1b
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        dt_nsb = x1b
        dt_eulerb = 0.0_8
      ELSE
        dt_eulerb = x1b
        dt_nsb = 0.0_8
      END IF
      htotb = w(i, j, 3)*gb(i, j, 5) + w(i, j, 2)*fb(i, j, 5)
      temp0 = gampr*mu(i, j)
      tempb = half*dist**2*dt_nsb/temp0
      rorb = tempb
      mub(i, j) = mub(i, j) - gampr*ror*tempb/temp0
      vitcb = -(dist*dt_eulerb/vitc**2)
      CALL POPREAL8(vitc)
      IF (velxi**2 + velyi**2 .EQ. 0.0) THEN
        tempb0 = 0.0_8
      ELSE
        tempb0 = vitcb/(2.0*SQRT(velxi**2+velyi**2))
      END IF
      ccb = vitcb
      velxib = 2*velxi*tempb0
      velyib = 2*velyi*tempb0
      pint = ror*rgaz*tloc(i, j)
      IF (gam*(pint*rom1) .EQ. 0.0) THEN
        tempb0 = 0.0_8
      ELSE
        tempb0 = gam*ccb/(2.0*SQRT(gam*(pint*rom1)))
      END IF
      pintb = rom1*tempb0 + gb(i, j, 3) + fb(i, j, 2) + rom1*htotb
      CALL POPREAL8(dist)
      temp = tloc(i, j)/(s_suth+tloc(i, j))
      temp0 = SQRT(tloc(i, j))
      tempb = temp0*betas*mub(i, j)/(s_suth+tloc(i, j))
      IF (tloc(i, j) .EQ. 0.0) THEN
        tlocb(i, j) = tlocb(i, j) + (1.0-temp)*tempb + ror*rgaz*pintb
      ELSE
        tlocb(i, j) = tlocb(i, j) + temp*betas*mub(i, j)/(2.0*temp0) + (&
&         1.0-temp)*tempb + ror*rgaz*pintb
      END IF
      mub(i, j) = 0.0_8
      htot = (w(i, j, 5)+pint)*rom1
      elocb = cvm1*tlocb(i, j)
      tlocb(i, j) = 0.0_8
      tempb = rom1*elocb
      wb(i, j, 5) = wb(i, j, 5) + rom1*htotb + tempb
      rorb = rorb + tloc(i, j)*rgaz*pintb - ec*tempb
      ecb = -(ror*tempb)
      tempb = half*ecb
      velzib = w(i, j, 3)*gb(i, j, 4) + w(i, j, 2)*fb(i, j, 4) + 2*velzi&
&       *tempb
      velyib = velyib + w(i, j, 3)*gb(i, j, 3) + w(i, j, 2)*fb(i, j, 3) &
&       + 2*velyi*tempb
      wb(i, j, 3) = wb(i, j, 3) + htot*gb(i, j, 5) + velzi*gb(i, j, 4) +&
&       velyi*gb(i, j, 3) + velxi*gb(i, j, 2) + gb(i, j, 1) + rom1*&
&       velyib
      gb(i, j, 5) = 0.0_8
      gb(i, j, 4) = 0.0_8
      gb(i, j, 3) = 0.0_8
      velxib = velxib + w(i, j, 3)*gb(i, j, 2) + w(i, j, 2)*fb(i, j, 2) &
&       + 2*velxi*tempb
      rom1b = pint*tempb0 + (w(i, j, 5)+pint)*htotb + (w(i, j, 5)-ec*ror&
&       )*elocb + w(i, j, 4)*velzib + w(i, j, 3)*velyib + w(i, j, 2)*&
&       velxib
      gb(i, j, 2) = 0.0_8
      gb(i, j, 1) = 0.0_8
      wb(i, j, 2) = wb(i, j, 2) + htot*fb(i, j, 5) + velzi*fb(i, j, 4) +&
&       velyi*fb(i, j, 3) + velxi*fb(i, j, 2) + fb(i, j, 1) + rom1*&
&       velxib
      fb(i, j, 5) = 0.0_8
      fb(i, j, 4) = 0.0_8
      fb(i, j, 3) = 0.0_8
      fb(i, j, 2) = 0.0_8
      fb(i, j, 1) = 0.0_8
      CALL POPREAL8(ec)
      CALL POPREAL8(velzi)
      wb(i, j, 4) = wb(i, j, 4) + rom1*velzib
      CALL POPREAL8(velyi)
      CALL POPREAL8(velxi)
      CALL POPREAL8(rom1)
      rorb = rorb - one*rom1b/ror**2
      CALL POPREAL8(ror)
      wb(i, j, 1) = wb(i, j, 1) + rorb
    END DO
  END DO
  dwib = 0.0_8
END SUBROUTINE IMPLI_MATRIX_FREE_2D_B
!

