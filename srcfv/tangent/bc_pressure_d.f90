!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of bc_pressure_2d in forward (tangent) mode (with options with!SliceDeadControl with!SliceDeadInstrs with!Stat
!icTaping):
!   variations   of useful results: w
!   with respect to varying inputs: w
!   RW status of diff variables: w:in-out
! This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed w
!ith this file, You can obtain one at https://mozilla.org/MPL/2.0/.
!
!==============================================================================
! BC Pressure No-Ref_2D: Euler & NS
!==============================================================================
!
SUBROUTINE BC_PRESSURE_2D_D(w, wd0, loc, interf, pext, noref, gam, nx, &
& ny, im, jm, gh, em)
  IMPLICIT NONE
! Variables for dimension ---------------------------------------------------
  INTEGER, INTENT(IN) :: im, jm
  INTEGER, INTENT(IN) :: gh, em
! Input variables -----------------------------------------------------------
  REAL*8, INTENT(IN) :: pext
  LOGICAL, INTENT(IN) :: noref
  REAL*8, INTENT(IN) :: gam
  CHARACTER(len=3), INTENT(IN) :: loc
  INTEGER, DIMENSION(2, 2), INTENT(IN) :: interf
  REAL*8, DIMENSION(1-gh:im+gh+1, 1-gh:jm+gh+1, 2), INTENT(IN) :: nx
  REAL*8, DIMENSION(1-gh:im+gh+1, 1-gh:jm+gh+1, 2), INTENT(IN) :: ny
! Returned objects ----------------------------------------------------------
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(INOUT) :: w
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(INOUT) :: wd0
! Local variables -----------------------------------------------------------
  REAL*8 :: ro0, ro0m1, uu, vv, ww, rovn0, epsm, epsp, eps0, p0
  REAL*8 :: ro0d, ro0m1d, uud, vvd, wwd, p0d
  REAL*8 :: ros, rosm1, us, vs, ws, ps, uts, vts, vns, c2s, c2sm1, rocs&
& , rocsm1
  REAL*8 :: rosd, rosm1d, usd, vsd, wsd, psd, utsd, vtsd, vnsd
  REAL*8 :: rod, rodm1, ud, vd, wd, pd, utd, vtd, vnd
  REAL*8 :: rodd, udd, vdd, wdd, utdd, vtdd, vndd
  REAL*8 :: ro, rom1, p, e, ut, vt, wt, vn, am, ap, bs, b0
  REAL*8 :: rod0, rom1d, pd0, utd0, vtd0, wtd, vnd0, amd, apd, bsd, b0d
  REAL*8 :: rou, rov, row, roe, roe1, roe2
  REAL*8 :: roud, rovd, rowd, roed, roe1d
  REAL*8 :: c20, c20m1, roc0, roc0m1, alpha
  REAL*8 :: c20d, c20m1d, roc0d, roc0m1d
  REAL*8 :: nxloc, nyloc, nsum, nsumi, sens
  REAL*8 :: nxnorm, nynorm, gam1, one, half, two
  INTEGER :: da, i1, j1, m
! ---------------------------------------------------------------------------
! Local variables -----------------------------------------------------------
  INTEGER :: kdir, de, i, j, imin, imax, jmin, jmax, lmin, lmax, l, i0, &
& j0, high
  INTRINSIC FLOAT
  INTRINSIC SQRT
  INTRINSIC SIGN
  REAL*8 :: arg1
  REAL*8 :: result1
  REAL*8 :: result1d
  REAL*8 :: temp
! ---------------------------------------------------------------------------
!
  imin = interf(1, 1)
  jmin = interf(1, 2)
  imax = interf(2, 1)
  jmax = interf(2, 2)
! write(200,*) loc, 'imin = ', interf(1,1)
! write(200,*) loc, 'jmin = ', interf(1,2)
! write(200,*) loc, 'imax = ', interf(2,1)
! write(200,*) loc, 'jmax = ', interf(2,2)
  i0 = 0
  j0 = 0
  high = 0
  lmin = 1
  IF (loc .EQ. 'Ilo') THEN
    kdir = 1
    i0 = 1
    lmax = jmax - jmin + 1
  ELSE IF (loc .EQ. 'Ihi') THEN
    kdir = 1
    i0 = -1
    lmax = jmax - jmin + 1
    high = 1
  ELSE IF (loc .EQ. 'Jlo') THEN
    kdir = 2
    j0 = 1
    lmax = imax - imin + 1
  ELSE IF (loc .EQ. 'Jhi') THEN
    kdir = 2
    j0 = -1
    lmax = imax - imin + 1
    high = 1
  END IF
  one = 1.d0
  half = 0.5d0
  gam1 = gam - one
!
  sens = FLOAT(i0 + j0)
!
  i1 = i0*i0
  j1 = j0*j0
  DO l=lmin,lmax
    i = imin + (l-lmin)*j1
    j = jmin + (l-lmin)*i1
! normals------------------------------------------------------------------
! NB: normals into the domain
    nxloc = nx(i+high*i1, j+high*j1, kdir)
    nyloc = ny(i+high*i1, j+high*j1, kdir)
! highis used to select the last normal when the face is of type *hi
    arg1 = nxloc*nxloc + nyloc*nyloc
    nsum = SQRT(arg1)
    nsumi = one/nsum
    nxnorm = nxloc*nsumi*sens
    nynorm = nyloc*nsumi*sens
! 0-State --------------------------------------------------------------
    ro0d = wd0(i, j, 1)
    ro0 = w(i, j, 1)
    ro0m1d = -(one*ro0d/ro0**2)
    ro0m1 = one/ro0
    uud = ro0m1*wd0(i, j, 2) + w(i, j, 2)*ro0m1d
    uu = w(i, j, 2)*ro0m1
    vvd = ro0m1*wd0(i, j, 3) + w(i, j, 3)*ro0m1d
    vv = w(i, j, 3)*ro0m1
    wwd = ro0m1*wd0(i, j, 4) + w(i, j, 4)*ro0m1d
    ww = w(i, j, 4)*ro0m1
    temp = uu*uu + vv*vv + ww*ww
    roe1d = wd0(i, j, 5) - half*(temp*ro0d+ro0*(2*uu*uud+2*vv*vvd+2*ww*&
&     wwd))
    roe1 = w(i, j, 5) - half*(ro0*temp)
    p0d = gam1*roe1d
    p0 = gam1*roe1
    c20d = gam*(ro0m1*p0d+p0*ro0m1d)
    c20 = gam*p0*ro0m1
    c20m1d = -(one*c20d/c20**2)
    c20m1 = one/c20
    temp = SQRT(c20)
    IF (c20 .EQ. 0.0) THEN
      result1d = 0.0_8
    ELSE
      result1d = c20d/(2.0*temp)
    END IF
    result1 = temp
    roc0d = result1*ro0d + ro0*result1d
    roc0 = ro0*result1
    roc0m1d = -(one*roc0d/roc0**2)
    roc0m1 = one/roc0
! sch-State ---------------------------------------------------------------
    rosd = wd0(i, j, 1)
    ros = w(i, j, 1)
    rosm1d = -(one*rosd/ros**2)
    rosm1 = one/ros
    usd = rosm1*wd0(i, j, 2) + w(i, j, 2)*rosm1d
    us = w(i, j, 2)*rosm1
    vsd = rosm1*wd0(i, j, 3) + w(i, j, 3)*rosm1d
    vs = w(i, j, 3)*rosm1
    wsd = rosm1*wd0(i, j, 4) + w(i, j, 4)*rosm1d
    ws = w(i, j, 4)*rosm1
    temp = us*us + vs*vs + ws*ws
    psd = gam1*(wd0(i, j, 5)-half*(temp*rosd+ros*(2*us*usd+2*vs*vsd+2*ws&
&     *wsd)))
    ps = gam1*(w(i, j, 5)-half*(ros*temp))
    vnsd = nxnorm*usd + nynorm*vsd
    vns = us*nxnorm + vs*nynorm
    utsd = usd - nxnorm*vnsd
    uts = us - vns*nxnorm
    vtsd = vsd - nynorm*vnsd
    vts = vs - vns*nynorm
! d-State --------------------------------------------------------------
    pd = pext
    rodd = rosd - c20m1*psd + (pd-ps)*c20m1d
    rod = ros + (pd-ps)*c20m1
! normal into the domain
    vndd = vnsd - roc0m1*psd + (pd-ps)*roc0m1d
    vnd = vns + (pd-ps)*roc0m1
    utdd = utsd
    utd = uts
    vtdd = vtsd
    vtd = vts
    udd = utdd + nxnorm*vndd
    ud = utd + vnd*nxnorm
    vdd = vtdd + nynorm*vndd
    vd = vtd + vnd*nynorm
    wdd = wsd
    wd = ws
! updated State -----------------------------------------------------------
    IF (noref) THEN
      rovn0 = w(i, j, 2)*nxnorm + w(i, j, 3)*nynorm
      epsm = half + SIGN(half, roc0 - rovn0)
      eps0 = half + SIGN(half, -rovn0)
      epsp = half + SIGN(half, -roc0 - rovn0)
      utd0 = eps0*utsd + (one-eps0)*utdd
      ut = eps0*uts + (one-eps0)*utd
      vtd0 = eps0*vtsd + (one-eps0)*vtdd
      vt = eps0*vts + (one-eps0)*vtd
      wtd = eps0*wsd + (one-eps0)*wdd
      wt = eps0*ws + (one-eps0)*wd
      amd = epsm*(psd-vns*roc0d-roc0*vnsd) - (one-epsm)*(vnd*roc0d+roc0*&
&       vndd)
      am = epsm*(ps-roc0*vns) + (one-epsm)*(pd-roc0*vnd)
      apd = epsp*(psd+vns*roc0d+roc0*vnsd) + (one-epsp)*(vnd*roc0d+roc0*&
&       vndd)
      ap = epsp*(ps+roc0*vns) + (one-epsp)*(pd+roc0*vnd)
      vnd0 = half*(roc0m1*(apd-amd)+(ap-am)*roc0m1d)
      vn = (ap-am)*half*roc0m1
      pd0 = half*(apd+amd)
      p = (ap+am)*half
      temp = (p-ps)*(ro0*ro0)
      bsd = roc0m1**2*(ro0**2*(pd0-psd)+(p-ps)*2*ro0*ro0d) + temp*2*&
&       roc0m1*roc0m1d + rosd
      bs = temp*(roc0m1*roc0m1) + ros
      temp = (p-pd)*(ro0*ro0)
      b0d = roc0m1**2*(ro0**2*pd0+(p-pd)*2*ro0*ro0d) + temp*2*roc0m1*&
&       roc0m1d + rodd
      b0 = temp*(roc0m1*roc0m1) + rod
      rod0 = eps0*bsd + (one-eps0)*b0d
      ro = eps0*bs + (one-eps0)*b0
      rom1d = -(one*rod0/ro**2)
      rom1 = one/ro
      roed = pd0/gam1
      roe = p/gam1
      roud = (ut+nxnorm*vn)*rod0 + ro*(utd0+nxnorm*vnd0)
      rou = ro*(ut+vn*nxnorm)
      rovd = (vt+nynorm*vn)*rod0 + ro*(vtd0+nynorm*vnd0)
      rov = ro*(vt+vn*nynorm)
      rowd = wt*rod0 + ro*wtd
      row = ro*wt
    ELSE
      p = pd
      rod0 = rodd
      ro = rod
      rom1d = -(one*rod0/ro**2)
      rom1 = one/ro
      roud = ud*rod0 + ro*udd
      rou = ro*ud
      rovd = vd*rod0 + ro*vdd
      rov = ro*vd
      rowd = wd*rod0 + ro*wdd
      row = ro*wd
      roe = p/gam1
      roed = 0.0_8
    END IF
    DO de=1,gh
      wd0(i-de*i0, j-de*j0, 1) = rod0
      w(i-de*i0, j-de*j0, 1) = ro
      wd0(i-de*i0, j-de*j0, 2) = roud
      w(i-de*i0, j-de*j0, 2) = rou
      wd0(i-de*i0, j-de*j0, 3) = rovd
      w(i-de*i0, j-de*j0, 3) = rov
      wd0(i-de*i0, j-de*j0, 4) = rowd
      w(i-de*i0, j-de*j0, 4) = row
      temp = rou*rou + rov*rov + row*row
      wd0(i-de*i0, j-de*j0, 5) = roed + half*(temp*rom1d+rom1*(2*rou*&
&       roud+2*rov*rovd+2*row*rowd))
      w(i-de*i0, j-de*j0, 5) = roe + half*(rom1*temp)
      DO m=6,em
        wd0(i-de*i0, j-de*j0, m) = ro0m1*ro*wd0(i, j, m) + w(i, j, m)*(&
&         ro*ro0m1d+ro0m1*rod0)
        w(i-de*i0, j-de*j0, m) = w(i, j, m)*ro0m1*ro
      END DO
    END DO
  END DO
END SUBROUTINE BC_PRESSURE_2D_D
!

