!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of impli_matrix_free_rans_2d in forward (tangent) mode (with options with!SliceDeadControl with!SliceDeadInstr
!s with!StaticTaping):
!   variations   of useful results: dwi
!   with respect to varying inputs: cfl dw w muref sigma nx ny
!                prandtl tref vol dtcoef volf s_suth src_i cs rgaz
!                cv gam
!   RW status of diff variables: cfl:in dw:in w:in muref:in sigma:in
!                nx:in ny:in prandtl:in tref:in vol:in dtcoef:in
!                volf:in s_suth:in src_i:in cs:in rgaz:in cv:in
!                dwi:out gam:in
! This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed w
!ith this file, You can obtain one at https://mozilla.org/MPL/2.0/.
! =============================================================================
! Implicit matrix free phase 2D RANS coupled
! =============================================================================
SUBROUTINE IMPLI_MATRIX_FREE_RANS_2D_D(dwi, dwid, nx, nxd, ny, nyd, &
& src_i, src_id, w, wd, mut, dw, dwd, vol, vold, volf, volfd, dtcoef, &
& dtcoefd, cfl, cfld, sigma, sigmad, gam, gamd, rgaz, rgazd, prandtl, &
& prandtld, prandtlturb, lmax, gh, cv, cvd, cs, csd, muref, murefd, tref&
& , trefd, s_suth, s_suthd, im, jm, em)
  IMPLICIT NONE
!
!
! variables for dimension -----------------------------------------
  INTEGER, INTENT(IN) :: em, im, jm, lmax
  INTEGER, INTENT(IN) :: gh
! required arguments ----------------------------------------------
  REAL*8, INTENT(IN) :: dtcoef, gam, rgaz, prandtl, prandtlturb, sigma
  REAL*8, INTENT(IN) :: dtcoefd, gamd, rgazd, prandtld, sigmad
  REAL*8, INTENT(IN) :: cv, cfl, cs, muref, tref, s_suth
  REAL*8, INTENT(IN) :: cvd, cfld, csd, murefd, trefd, s_suthd
  REAL*8, DIMENSION(1-gh:im+1+gh, 1-gh:jm+1+gh, 2), INTENT(IN) :: nx, ny
  REAL*8, DIMENSION(1-gh:im+1+gh, 1-gh:jm+1+gh, 2), INTENT(IN) :: nxd, &
& nyd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2), INTENT(IN) :: volf
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2), INTENT(IN) :: volfd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: vol
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: vold
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(IN) :: w
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(IN) :: wd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(IN) :: dw
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(IN) :: dwd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: mut
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: src_i
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: src_id
! Returned objects ------------------------------------------------
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(INOUT) :: dwi
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(INOUT) :: dwid
! Local variables -------------------------------------------------
  INTEGER :: i, j, l, equa, kdir, i0, j0, ipt, le, eq2
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: mu, tloc
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: mud, tlocd
  REAL*8, DIMENSION(0:im+1, 0:jm+1, em) :: d2w, dfi, dgi, hn, f, g
  REAL*8, DIMENSION(0:im+1, 0:jm+1, em) :: d2wd, dfid, dgid, hnd, fd, gd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2) :: coefdiag
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2) :: coefdiagd
!specrad
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2, 2) :: coef
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2, 2) :: coefd
  REAL*8, DIMENSION(em) :: wi, fi, gi
  REAL*8, DIMENSION(em) :: wid, fid, gid
  REAL*8 :: velxi, velyi, velzi, pint, tint, htot
  REAL*8 :: velxid, velyid, velzid, pintd, htotd
  REAL*8 :: rhom1, roki, norm, specdiff, iro, rol, ror, sigmainv
  REAL*8 :: rhom1d, normd, specdiffd, irod, rold, rord, sigmainvd
  REAL*8 :: one, half, zero, two, rom1l, rom1r, gampr, gamprt, mutot, &
& difftur
  REAL*8 :: rom1ld, rom1rd, gamprd, mutotd, diffturd
  REAL*8 :: uu, vv, cc, gam1, itur
  REAL*8 :: uud, vvd, ccd, gam1d
  REAL*8 :: dist, vitc, dt_euler, dt_ns, cflm1, distm1, cvm1
  REAL*8 :: distd, vitcd, dt_eulerd, dt_nsd, cflm1d, cvm1d
  REAL*8 :: ec, eloc, betas, rom1, dtm1, dt
  REAL*8 :: ecd, elocd, betasd, rom1d, dtm1d
  INTRINSIC SQRT
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC ABS
  REAL*8 :: x1
  REAL*8 :: x1d
  REAL*8 :: x2
  REAL*8 :: x2d
  REAL*8 :: x3
  REAL*8 :: x3d
  REAL*8 :: max1
  REAL*8 :: max1d
  REAL*8 :: abs0
  REAL*8 :: abs0d
  REAL*8 :: abs1
  REAL*8 :: abs1d
  REAL*8 :: result1
  REAL*8 :: result1d
  REAL*8 :: arg1
  REAL*8 :: arg1d
  REAL*8 :: arg2
  REAL*8 :: arg2d
  REAL*8 :: result2
  REAL*8 :: result2d
  REAL*8 :: temp
  REAL*8 :: temp0
  REAL*8, DIMENSION(em) :: temp1
  REAL*8, DIMENSION(em) :: temp2
  REAL*8 :: temp3
  REAL*8, DIMENSION(im, jm) :: temp4
! -----------------------------------------------------------------
  half = 0.5d0
  zero = 0.d0
  two = 2.d0
  one = 1.d0
!
  dwi = zero
  dfi = zero
  dgi = zero
!
  gamprd = 2.d0*(gamd-gam*prandtld/prandtl)/prandtl
  gampr = 2.d0*gam/prandtl
  gam1d = gamd
  gam1 = gam - one
!
  cflm1d = -(one*cfld/cfl**2)
  cflm1 = one/cfl
  cvm1d = -(one*cvd/cv**2)
  cvm1 = one/cv
  temp = SQRT(tref)
  IF (tref .EQ. 0.0) THEN
    result1d = 0.0_8
  ELSE
    result1d = trefd/(2.0*temp)
  END IF
  result1 = temp
  temp = muref*(tref+cs)/(result1*tref)
  betasd = ((tref+cs)*murefd+muref*(trefd+csd)-temp*(tref*result1d+&
&   result1*trefd))/(result1*tref)
  betas = temp
  sigmainvd = -(one*sigmad/sigma**2)
  sigmainv = one/sigma
  fd = 0.0_8
  gd = 0.0_8
  coefdiagd = 0.0_8
  tlocd = 0.0_8
  mud = 0.0_8
  DO j=1-gh,jm+gh
    DO i=1-gh,im+gh
      rord = wd(i, j, 1)
      ror = w(i, j, 1)
      rom1d = -(one*rord/ror**2)
      rom1 = one/ror
      velxid = rom1*wd(i, j, 2) + w(i, j, 2)*rom1d
      velxi = w(i, j, 2)*rom1
      velyid = rom1*wd(i, j, 3) + w(i, j, 3)*rom1d
      velyi = w(i, j, 3)*rom1
      velzid = rom1*wd(i, j, 4) + w(i, j, 4)*rom1d
      velzi = w(i, j, 4)*rom1
!
      ecd = half*(2*velxi*velxid+2*velyi*velyid+2*velzi*velzid)
      ec = half*(velxi*velxi+velyi*velyi+velzi*velzi)
!
      temp = w(i, j, 5) - ec*ror
      elocd = rom1*(wd(i, j, 5)-ror*ecd-ec*rord) + temp*rom1d
      eloc = temp*rom1
!
      tlocd(i, j) = cvm1*elocd + eloc*cvm1d
      tloc(i, j) = eloc*cvm1
!
      pintd = tloc(i, j)*(rgaz*rord+ror*rgazd) + ror*rgaz*tlocd(i, j)
      pint = ror*rgaz*tloc(i, j)
      htotd = rom1*(wd(i, j, 5)+pintd) + (w(i, j, 5)+pint)*rom1d
      htot = (w(i, j, 5)+pint)*rom1
      fd(i, j, 1) = wd(i, j, 2)
      f(i, j, 1) = w(i, j, 2)
      fd(i, j, 2) = velxi*wd(i, j, 2) + w(i, j, 2)*velxid + pintd
      f(i, j, 2) = w(i, j, 2)*velxi + pint
      fd(i, j, 3) = velyi*wd(i, j, 2) + w(i, j, 2)*velyid
      f(i, j, 3) = w(i, j, 2)*velyi
      fd(i, j, 4) = velzi*wd(i, j, 2) + w(i, j, 2)*velzid
      f(i, j, 4) = w(i, j, 2)*velzi
      fd(i, j, 5) = htot*wd(i, j, 2) + w(i, j, 2)*htotd
      f(i, j, 5) = w(i, j, 2)*htot
      gd(i, j, 1) = wd(i, j, 3)
      g(i, j, 1) = w(i, j, 3)
      gd(i, j, 2) = velxi*wd(i, j, 3) + w(i, j, 3)*velxid
      g(i, j, 2) = w(i, j, 3)*velxi
      gd(i, j, 3) = velyi*wd(i, j, 3) + w(i, j, 3)*velyid + pintd
      g(i, j, 3) = w(i, j, 3)*velyi + pint
      gd(i, j, 4) = velzi*wd(i, j, 3) + w(i, j, 3)*velzid
      g(i, j, 4) = w(i, j, 3)*velzi
      gd(i, j, 5) = htot*wd(i, j, 3) + w(i, j, 3)*htotd
      g(i, j, 5) = w(i, j, 3)*htot
!h(i,j,1) = w(i,j,4)
!h(i,j,2) = w(i,j,4) * velx(i,j)
!h(i,j,3) = w(i,j,4) * vely(i,j)
!h(i,j,4) = w(i,j,4) * velz(i,j) + pint
!h(i,j,5) = w(i,j,4) * htot
      temp = SQRT(tloc(i, j))
      IF (tloc(i, j) .EQ. 0.0) THEN
        result1d = 0.0_8
      ELSE
        result1d = tlocd(i, j)/(2.0*temp)
      END IF
      result1 = temp
      temp = betas*result1*tloc(i, j)/(tloc(i, j)+s_suth)
      mud(i, j) = (tloc(i, j)*(result1*betasd+betas*result1d)+betas*&
&       result1*tlocd(i, j)-temp*(tlocd(i, j)+s_suthd))/(tloc(i, j)+&
&       s_suth)
      mu(i, j) = temp
      DO itur=6,em
        temp = w(i, j, 2)*rom1
        fd(i, j, itur) = w(i, j, itur)*(rom1*wd(i, j, 2)+w(i, j, 2)*&
&         rom1d) + temp*wd(i, j, itur)
        f(i, j, itur) = temp*w(i, j, itur)
        temp = w(i, j, 3)*rom1
        gd(i, j, itur) = w(i, j, itur)*(rom1*wd(i, j, 3)+w(i, j, 3)*&
&         rom1d) + temp*wd(i, j, itur)
        g(i, j, itur) = temp*w(i, j, itur)
      END DO
      arg1d = 2*nx(i, j, 1)*nxd(i, j, 1) + 2*ny(i, j, 1)*nyd(i, j, 1)
      arg1 = nx(i, j, 1)*nx(i, j, 1) + ny(i, j, 1)*ny(i, j, 1)
      temp = SQRT(arg1)
      IF (arg1 .EQ. 0.0) THEN
        result1d = 0.0_8
      ELSE
        result1d = arg1d/(2.0*temp)
      END IF
      result1 = temp
      arg2d = 2*nx(i, j, 2)*nxd(i, j, 2) + 2*ny(i, j, 2)*nyd(i, j, 2)
      arg2 = nx(i, j, 2)*nx(i, j, 2) + ny(i, j, 2)*ny(i, j, 2)
      temp = SQRT(arg2)
      IF (arg2 .EQ. 0.0) THEN
        result2d = 0.0_8
      ELSE
        result2d = arg2d/(2.0*temp)
      END IF
      result2 = temp
      temp = vol(i, j)/(result1+result2)
      distd = (vold(i, j)-temp*(result1d+result2d))/(result1+result2)
      dist = temp
      arg1d = rom1*(pint*gamd+gam*pintd) + gam*pint*rom1d
      arg1 = gam*pint*rom1
      temp = SQRT(arg1)
      IF (arg1 .EQ. 0.0) THEN
        ccd = 0.0_8
      ELSE
        ccd = arg1d/(2.0*temp)
      END IF
      cc = temp
      arg1d = 2*velxi*velxid + 2*velyi*velyid
      arg1 = velxi*velxi + velyi*velyi
      temp = SQRT(arg1)
      IF (arg1 .EQ. 0.0) THEN
        result1d = 0.0_8
      ELSE
        result1d = arg1d/(2.0*temp)
      END IF
      result1 = temp
      vitcd = result1d + ccd
      vitc = result1 + cc
      dt_eulerd = (distd-dist*vitcd/vitc)/vitc
      dt_euler = dist/vitc
      temp = gampr*mu(i, j)
      temp0 = dist*dist*ror/temp
      dt_nsd = half*(ror*2*dist*distd+dist**2*rord-temp0*(mu(i, j)*&
&       gamprd+gampr*mud(i, j)))/temp
      dt_ns = half*temp0
      IF (dt_euler .GT. dt_ns) THEN
        x1d = dt_nsd
        x1 = dt_ns
      ELSE
        x1d = dt_eulerd
        x1 = dt_euler
      END IF
      IF (x1 .LT. 1.d-15) THEN
        max1 = 1.d-15
        max1d = 0.0_8
      ELSE
        max1d = x1d
        max1 = x1
      END IF
! 1/dt
      dtm1d = (cflm1d-cflm1*max1d/max1)/max1
      dtm1 = cflm1/max1
!write(30101,*) "i,j    =  ", i,j
!write(30101,*) "dtm1   =  ", dtm1
!write(30101,*) "distm1 =  ", distm1
!write(30101,*) "cflm1  =  ", dtm1
!write(30101,*) "mu     =  ", mu(i,j)
! compute diagonal coefficient------------------------------------------------------
! 1/dt ou 1.5/dt
      coefdiagd(1:im, 1:jm, 1) = vol(1:im, 1:jm)*(dtm1*dtcoefd+dtcoef*&
&       dtm1d) + dtcoef*dtm1*vold(1:im, 1:jm)
      coefdiag(1:im, 1:jm, 1) = dtcoef*dtm1*vol(1:im, 1:jm)
! 1/dt ou 1.5/dt
      coefdiagd(1:im, 1:jm, 2) = vol(1:im, 1:jm)*(dtm1*dtcoefd+dtcoef*&
&       dtm1d) + dtcoef*dtm1*vold(1:im, 1:jm)
      coefdiag(1:im, 1:jm, 2) = dtcoef*dtm1*vol(1:im, 1:jm)
    END DO
  END DO
  coefd = 0.0_8
!
loop_kdir:DO kdir=1,2
    i0 = -kdir + 2
    j0 = kdir - 1
!
    DO j=1,jm+1
      DO i=1,im+1
        rold = wd(i-i0, j-j0, 1)
        rol = w(i-i0, j-j0, 1)
        rord = wd(i, j, 1)
        ror = w(i, j, 1)
        rom1ld = -(one*rold/rol**2)
        rom1l = one/rol
        rom1rd = -(one*rord/ror**2)
        rom1r = one/ror
        temp0 = 2.d0/(rol+ror)
        irod = -(temp0*(rold+rord)/(rol+ror))
        iro = temp0
        temp0 = w(i-i0, j-j0, 2)
        uud = half*(rom1l*wd(i-i0, j-j0, 2)+temp0*rom1ld+rom1r*wd(i, j, &
&         2)+w(i, j, 2)*rom1rd)
        uu = half*(temp0*rom1l+w(i, j, 2)*rom1r)
        temp0 = w(i-i0, j-j0, 3)
        vvd = half*(rom1l*wd(i-i0, j-j0, 3)+temp0*rom1ld+rom1r*wd(i, j, &
&         3)+w(i, j, 3)*rom1rd)
        vv = half*(temp0*rom1l+w(i, j, 3)*rom1r)
        temp0 = tloc(i-i0, j-j0) + tloc(i, j)
        ccd = half*(temp0*(rgaz*gamd+gam*rgazd)+gam*rgaz*(tlocd(i-i0, j-&
&         j0)+tlocd(i, j)))
        cc = half*(gam*rgaz*temp0)
        normd = 2*nx(i, j, kdir)*nxd(i, j, kdir) + 2*ny(i, j, kdir)*nyd(&
&         i, j, kdir)
        norm = nx(i, j, kdir)*nx(i, j, kdir) + ny(i, j, kdir)*ny(i, j, &
&         kdir)
        temp0 = mu(i-i0, j-j0) + mu(i, j)
        mutotd = half*(temp0*gamprd+gampr*(mud(i-i0, j-j0)+mud(i, j)))
        mutot = half*(gampr*temp0)
        temp0 = mutot*norm*iro
        specdiffd = volf(i, j, kdir)*(iro*(norm*mutotd+mutot*normd)+&
&         mutot*norm*irod) + temp0*volfd(i, j, kdir)
        specdiff = temp0*volf(i, j, kdir)
        x2d = nx(i, j, kdir)*uud + uu*nxd(i, j, kdir) + ny(i, j, kdir)*&
&         vvd + vv*nyd(i, j, kdir)
        x2 = uu*nx(i, j, kdir) + vv*ny(i, j, kdir)
        IF (x2 .GE. 0.) THEN
          abs0d = x2d
          abs0 = x2
        ELSE
          abs0d = -x2d
          abs0 = -x2
        END IF
        arg1d = norm*ccd + cc*normd
        arg1 = cc*norm
        temp0 = SQRT(arg1)
        IF (arg1 .EQ. 0.0) THEN
          result1d = 0.0_8
        ELSE
          result1d = arg1d/(2.0*temp0)
        END IF
        result1 = temp0
        coefd(i, j, 1, kdir) = 0.5d0*(abs0d+result1d+two*specdiffd)
        coef(i, j, 1, kdir) = 0.5d0*(abs0+result1+two*specdiff)
        mutotd = half*(mud(i-i0, j-j0)+mud(i, j)+wd(i-i0, j-j0, 6)+wd(i&
&         , j, 6))
        mutot = half*(mu(i-i0, j-j0)+mu(i, j)+w(i-i0, j-j0, 6)+w(i, j, 6&
&         ))
! mutot = HALF * ( mu(i-i0,j-j0) + mu(i,j) + mut(i-i0,j-j0) + mut(i,j) )
        temp0 = mutot*sigmainv*norm*iro
        diffturd = temp0*volfd(i, j, kdir) + volf(i, j, kdir)*(norm*iro*&
&         (sigmainv*mutotd+mutot*sigmainvd)+mutot*sigmainv*(iro*normd+&
&         norm*irod))
        difftur = volf(i, j, kdir)*temp0
        x3d = nx(i, j, kdir)*uud + uu*nxd(i, j, kdir) + ny(i, j, kdir)*&
&         vvd + vv*nyd(i, j, kdir)
        x3 = uu*nx(i, j, kdir) + vv*ny(i, j, kdir)
        IF (x3 .GE. 0.) THEN
          abs1d = x3d
          abs1 = x3
        ELSE
          abs1d = -x3d
          abs1 = -x3
        END IF
        arg1d = norm*ccd + cc*normd
        arg1 = cc*norm
        temp0 = SQRT(arg1)
        IF (arg1 .EQ. 0.0) THEN
          result1d = 0.0_8
        ELSE
          result1d = arg1d/(2.0*temp0)
        END IF
        result1 = temp0
        coefd(i, j, 2, kdir) = 0.5d0*(abs1d+result1d+two*diffturd)
        coef(i, j, 2, kdir) = 0.5d0*(abs1+result1+two*difftur)
      END DO
    END DO
    DO j=1,jm
      DO i=1,im
        coefdiagd(i, j, 1) = coefdiagd(i, j, 1) + coefd(i, j, 1, kdir) +&
&         coefd(i+i0, j+j0, 1, kdir)
        coefdiag(i, j, 1) = coefdiag(i, j, 1) + coef(i, j, 1, kdir) + &
&         coef(i+i0, j+j0, 1, kdir)
        coefdiagd(i, j, 2) = coefdiagd(i, j, 2) + coefd(i, j, 2, kdir) +&
&         coefd(i+i0, j+j0, 2, kdir)
        coefdiag(i, j, 2) = coefdiag(i, j, 2) + coef(i, j, 2, kdir) + &
&         coef(i+i0, j+j0, 2, kdir)
      END DO
    END DO
  END DO loop_kdir
  dwid = 0.0_8
  hnd = 0.0_8
  fid = 0.0_8
  dfid = 0.0_8
  d2wd = 0.0_8
  gid = 0.0_8
  dgid = 0.0_8
!
loop_subite:DO l=1,lmax
!
    DO equa=1,em
      d2wd(0:im+1, 0:jm+1, equa) = vol(0:im+1, 0:jm+1)*dwd(0:im+1, 0:jm+&
&       1, equa) + dw(0:im+1, 0:jm+1, equa)*vold(0:im+1, 0:jm+1)
      d2w(0:im+1, 0:jm+1, equa) = dw(0:im+1, 0:jm+1, equa)*vol(0:im+1, 0&
&       :jm+1)
    END DO
!
! Computation of the left hand side
!
loop_kdir_inner:DO kdir=1,2
      i0 = -kdir + 2
      j0 = kdir - 1
!
      DO j=1,jm+j0
        DO i=1,im+i0
!norm = dsqrt( nx(i,j,kdir)**2 + ny(i,j,kdir)**2)
          temp1 = dfi(i-i0, j-j0, :) + dfi(i, j, :)
          temp2 = dgi(i-i0, j-j0, :) + dgi(i, j, :)
          hnd(i, j, :) = half*(nx(i, j, kdir)*(dfid(i-i0, j-j0, :)+dfid(&
&           i, j, :))+temp1*nxd(i, j, kdir)) + half*(ny(i, j, kdir)*(&
&           dgid(i-i0, j-j0, :)+dgid(i, j, :))+temp2*nyd(i, j, kdir))
          hn(i, j, :) = half*(temp1*nx(i, j, kdir)) + half*(temp2*ny(i, &
&           j, kdir))
        END DO
      END DO
!
      DO j=1,jm
        DO i=1,im
          temp0 = coef(i+i0, j+j0, 1, kdir)
          d2wd(i, j, 1:5) = d2wd(i, j, 1:5) + hnd(i, j, 1:5) - hnd(i+i0&
&           , j+j0, 1:5) + dwi(i-i0, j-j0, 1:5)*coefd(i, j, 1, kdir) + &
&           coef(i, j, 1, kdir)*dwid(i-i0, j-j0, 1:5) + dwi(i+i0, j+j0, &
&           1:5)*coefd(i+i0, j+j0, 1, kdir) + temp0*dwid(i+i0, j+j0, 1:5&
&           )
          d2w(i, j, 1:5) = d2w(i, j, 1:5) + hn(i, j, 1:5) - hn(i+i0, j+&
&           j0, 1:5) + coef(i, j, 1, kdir)*dwi(i-i0, j-j0, 1:5) + temp0*&
&           dwi(i+i0, j+j0, 1:5)
        END DO
      END DO
      DO equa=6,em
        DO j=1,jm
          DO i=1,im
            temp0 = dwi(i-i0, j-j0, equa)
            temp = dwi(i+i0, j+j0, equa)
            temp3 = coef(i+i0, j+j0, 2, kdir)
            d2wd(i, j, equa) = d2wd(i, j, equa) + hnd(i, j, equa) - hnd(&
&             i+i0, j+j0, equa) + temp0*coefd(i, j, 2, kdir) + coef(i, j&
&             , 2, kdir)*dwid(i-i0, j-j0, equa) + temp*coefd(i+i0, j+j0&
&             , 2, kdir) + temp3*dwid(i+i0, j+j0, equa)
            d2w(i, j, equa) = d2w(i, j, equa) + hn(i, j, equa) - hn(i+i0&
&             , j+j0, equa) + coef(i, j, 2, kdir)*temp0 + temp3*temp
          END DO
        END DO
      END DO
    END DO loop_kdir_inner
!
! Computation of the intermediate increment
!
    temp4 = d2w(1:im, 1:jm, 1)/coefdiag(1:im, 1:jm, 1)
    dwid(1:im, 1:jm, 1) = (d2wd(1:im, 1:jm, 1)-temp4*coefdiagd(1:im, 1:&
&     jm, 1))/coefdiag(1:im, 1:jm, 1)
    dwi(1:im, 1:jm, 1) = temp4
    temp4 = d2w(1:im, 1:jm, 2)/coefdiag(1:im, 1:jm, 1)
    dwid(1:im, 1:jm, 2) = (d2wd(1:im, 1:jm, 2)-temp4*coefdiagd(1:im, 1:&
&     jm, 1))/coefdiag(1:im, 1:jm, 1)
    dwi(1:im, 1:jm, 2) = temp4
    temp4 = d2w(1:im, 1:jm, 3)/coefdiag(1:im, 1:jm, 1)
    dwid(1:im, 1:jm, 3) = (d2wd(1:im, 1:jm, 3)-temp4*coefdiagd(1:im, 1:&
&     jm, 1))/coefdiag(1:im, 1:jm, 1)
    dwi(1:im, 1:jm, 3) = temp4
    temp4 = d2w(1:im, 1:jm, 4)/coefdiag(1:im, 1:jm, 1)
    dwid(1:im, 1:jm, 4) = (d2wd(1:im, 1:jm, 4)-temp4*coefdiagd(1:im, 1:&
&     jm, 1))/coefdiag(1:im, 1:jm, 1)
    dwi(1:im, 1:jm, 4) = temp4
    temp4 = d2w(1:im, 1:jm, 5)/coefdiag(1:im, 1:jm, 1)
    dwid(1:im, 1:jm, 5) = (d2wd(1:im, 1:jm, 5)-temp4*coefdiagd(1:im, 1:&
&     jm, 1))/coefdiag(1:im, 1:jm, 1)
    dwi(1:im, 1:jm, 5) = temp4
    DO equa=6,em
      temp4 = d2w(1:im, 1:jm, equa)/(coefdiag(1:im, 1:jm, 2)+src_i(1:im&
&       , 1:jm))
      dwid(1:im, 1:jm, equa) = (d2wd(1:im, 1:jm, equa)-temp4*(coefdiagd(&
&       1:im, 1:jm, 2)+src_id(1:im, 1:jm)))/(coefdiag(1:im, 1:jm, 2)+&
&       src_i(1:im, 1:jm))
      dwi(1:im, 1:jm, equa) = temp4
    END DO
!
! Actualisation de wi
!
    DO j=1,jm
      DO i=1,im
        wid(:) = wd(i, j, :) + dwid(i, j, :)
        wi(:) = w(i, j, :) + dwi(i, j, :)
        temp3 = one/wi(1)
        rhom1d = -(temp3*wid(1)/wi(1))
        rhom1 = temp3
        velxid = rhom1*wid(2) + wi(2)*rhom1d
        velxi = wi(2)*rhom1
        velyid = rhom1*wid(3) + wi(3)*rhom1d
        velyi = wi(3)*rhom1
        velzid = rhom1*wid(4) + wi(4)*rhom1d
        velzi = wi(4)*rhom1
        temp3 = velxi*velxi + velyi*velyi + velzi*velzi
        temp0 = wi(5) - half*wi(1)*temp3
        pintd = temp0*gam1d + gam1*(wid(5)-half*(temp3*wid(1)+wi(1)*(2*&
&         velxi*velxid+2*velyi*velyid+2*velzi*velzid)))
        pint = gam1*temp0
!
! Actualisation des flux intermediaires
        fid(1) = wid(2)
        fi(1) = wi(2)
        fid(2) = velxi*wid(2) + wi(2)*velxid + pintd
        fi(2) = wi(2)*velxi + pint
        fid(3) = velyi*wid(2) + wi(2)*velyid
        fi(3) = wi(2)*velyi
        fid(4) = velzi*wid(2) + wi(2)*velzid
        fi(4) = wi(2)*velzi
        fid(5) = (wi(5)+pint)*velxid + velxi*(wid(5)+pintd)
        fi(5) = velxi*(wi(5)+pint)
        gid(1) = wid(3)
        gi(1) = wi(3)
        gid(2) = velxi*wid(3) + wi(3)*velxid
        gi(2) = wi(3)*velxi
        gid(3) = velyi*wid(3) + wi(3)*velyid + pintd
        gi(3) = wi(3)*velyi + pint
        gid(4) = velzi*wid(3) + wi(3)*velzid
        gi(4) = wi(3)*velzi
        gid(5) = (wi(5)+pint)*velyid + velyi*(wid(5)+pintd)
        gi(5) = velyi*(wi(5)+pint)
! turbulent quantities
        fid(6:em) = wi(6:em)*velxid + velxi*wid(6:em)
        fi(6:em) = velxi*wi(6:em)
        gid(6:em) = wi(6:em)*velyid + velyi*wid(6:em)
        gi(6:em) = velyi*wi(6:em)
! Calcul des increments des flux
        dfid(i, j, :) = fid(:) - fd(i, j, :)
        dfi(i, j, :) = fi(:) - f(i, j, :)
        dgid(i, j, :) = gid(:) - gd(i, j, :)
        dgi(i, j, :) = gi(:) - g(i, j, :)
      END DO
    END DO
  END DO loop_subite
END SUBROUTINE IMPLI_MATRIX_FREE_RANS_2D_D
!

