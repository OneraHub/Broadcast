!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of impli_matrix_free_2d in forward (tangent) mode (with options with!SliceDeadControl with!SliceDeadInstrs wit
!h!StaticTaping):
!   variations   of useful results: dwi
!   with respect to varying inputs: w
!   RW status of diff variables: w:in dwi:out
! This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed w
!ith this file, You can obtain one at https://mozilla.org/MPL/2.0/.
! =============================================================================
! Implicit matrix free phase 2D NS
! =============================================================================
SUBROUTINE IMPLI_MATRIX_FREE_2D_D(dwi, dwid, nx, ny, w, wd, dw, vol, &
& volf, dtcoef, cfl, gam, rgaz, prandtl, lmax, gh, cv, cs, muref, tref, &
& s_suth, im, jm, em)
  IMPLICIT NONE
!
!
! variables for dimension -----------------------------------------
  INTEGER, INTENT(IN) :: em, im, jm, lmax
  INTEGER, INTENT(IN) :: gh
! required arguments ----------------------------------------------
  REAL*8, INTENT(IN) :: dtcoef, gam, rgaz, prandtl, cfl, cs, muref, tref&
& , s_suth, cv
  REAL*8, DIMENSION(1-gh:im+1+gh, 1-gh:jm+1+gh, 2), INTENT(IN) :: nx, ny
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2), INTENT(IN) :: volf
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: vol
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(IN) :: w
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(IN) :: wd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(IN) :: dw
! Returned objects ------------------------------------------------
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(INOUT) :: dwi
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em), INTENT(INOUT) :: dwid
! Local variables -------------------------------------------------
  INTEGER :: i, j, l, equa, kdir, i0, j0, ipt, le, eq2
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: tloc, mu
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: tlocd, mud
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em) :: d2w, dfi, dgi, hn, f&
& , g
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, em) :: d2wd, dfid, dgid, hnd&
& , fd, gd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: coefdiag
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: coefdiagd
!specrad
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2) :: coef
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2) :: coefd
  REAL*8, DIMENSION(em) :: wi, fi, gi
  REAL*8, DIMENSION(em) :: wid, fid, gid
  REAL*8 :: velxi, velyi, velzi, pint, tint, htot
  REAL*8 :: velxid, velyid, velzid, pintd, htotd
  REAL*8 :: rhom1, roki, norm, specdiff, iro, rol, ror, rom1
  REAL*8 :: rhom1d, specdiffd, irod, rold, rord, rom1d
  REAL*8 :: one, half, zero, two, rom1l, rom1r, gampr, gamprt
  REAL*8 :: rom1ld, rom1rd
  REAL*8 :: uu, vv, cc, gam1, mutot
  REAL*8 :: uud, vvd, ccd, mutotd
  REAL*8 :: dtm1, dist, vitc, dt_euler, dt_ns, cvm1
  REAL*8 :: dtm1d, vitcd, dt_eulerd, dt_nsd
  REAL*8 :: ec, eloc, betas, diagm1, cflm1, dtm1save
  REAL*8 :: ecd, elocd, diagm1d
  INTRINSIC SQRT
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC ABS
  REAL*8 :: x1
  REAL*8 :: x1d
  REAL*8 :: x2
  REAL*8 :: x2d
  REAL*8 :: max1
  REAL*8 :: max1d
  REAL*8 :: abs0
  REAL*8 :: abs0d
  REAL*8 :: result1
  REAL*8 :: result1d
  REAL*8 :: arg1
  REAL*8 :: arg1d
  REAL*8 :: arg2
  REAL*8 :: result2
  REAL*8 :: temp
  REAL*8 :: temp0
! -----------------------------------------------------------------
  half = 0.5d0
  zero = 0.d0
  two = 2.d0
  one = 1.d0
!
  dwi = zero
  dfi = zero
  dgi = zero
!
  gampr = 2.d0*gam/prandtl
  gam1 = gam - one
!
  cflm1 = one/cfl
  cvm1 = one/cv
  result1 = SQRT(tref)
  betas = muref*(tref+cs)/(result1*tref)
  fd = 0.0_8
  gd = 0.0_8
  coefdiagd = 0.0_8
  tlocd = 0.0_8
  mud = 0.0_8
  DO j=1-gh,jm+gh
    DO i=1-gh,im+gh
      rord = wd(i, j, 1)
      ror = w(i, j, 1)
      rom1d = -(one*rord/ror**2)
      rom1 = one/ror
      velxid = rom1*wd(i, j, 2) + w(i, j, 2)*rom1d
      velxi = w(i, j, 2)*rom1
      velyid = rom1*wd(i, j, 3) + w(i, j, 3)*rom1d
      velyi = w(i, j, 3)*rom1
      velzid = rom1*wd(i, j, 4) + w(i, j, 4)*rom1d
      velzi = w(i, j, 4)*rom1
!
      ecd = half*(2*velxi*velxid+2*velyi*velyid+2*velzi*velzid)
      ec = half*(velxi*velxi+velyi*velyi+velzi*velzi)
!
      temp = w(i, j, 5) - ec*ror
      elocd = rom1*(wd(i, j, 5)-ror*ecd-ec*rord) + temp*rom1d
      eloc = temp*rom1
!
      tlocd(i, j) = cvm1*elocd
      tloc(i, j) = eloc*cvm1
!
      pintd = rgaz*(tloc(i, j)*rord+ror*tlocd(i, j))
      pint = ror*rgaz*tloc(i, j)
      htotd = rom1*(wd(i, j, 5)+pintd) + (w(i, j, 5)+pint)*rom1d
      htot = (w(i, j, 5)+pint)*rom1
      fd(i, j, 1) = wd(i, j, 2)
      f(i, j, 1) = w(i, j, 2)
      fd(i, j, 2) = velxi*wd(i, j, 2) + w(i, j, 2)*velxid + pintd
      f(i, j, 2) = w(i, j, 2)*velxi + pint
      fd(i, j, 3) = velyi*wd(i, j, 2) + w(i, j, 2)*velyid
      f(i, j, 3) = w(i, j, 2)*velyi
      fd(i, j, 4) = velzi*wd(i, j, 2) + w(i, j, 2)*velzid
      f(i, j, 4) = w(i, j, 2)*velzi
      fd(i, j, 5) = htot*wd(i, j, 2) + w(i, j, 2)*htotd
      f(i, j, 5) = w(i, j, 2)*htot
      gd(i, j, 1) = wd(i, j, 3)
      g(i, j, 1) = w(i, j, 3)
      gd(i, j, 2) = velxi*wd(i, j, 3) + w(i, j, 3)*velxid
      g(i, j, 2) = w(i, j, 3)*velxi
      gd(i, j, 3) = velyi*wd(i, j, 3) + w(i, j, 3)*velyid + pintd
      g(i, j, 3) = w(i, j, 3)*velyi + pint
      gd(i, j, 4) = velzi*wd(i, j, 3) + w(i, j, 3)*velzid
      g(i, j, 4) = w(i, j, 3)*velzi
      gd(i, j, 5) = htot*wd(i, j, 3) + w(i, j, 3)*htotd
      g(i, j, 5) = w(i, j, 3)*htot
!h(i,j,1) = w(i,j,4)
!h(i,j,2) = w(i,j,4) * velx(i,j)
!h(i,j,3) = w(i,j,4) * vely(i,j)
!h(i,j,4) = w(i,j,4) * velz(i,j) + pint
!h(i,j,5) = w(i,j,4) * htot
      temp = SQRT(tloc(i, j))
      IF (tloc(i, j) .EQ. 0.0) THEN
        result1d = 0.0_8
      ELSE
        result1d = tlocd(i, j)/(2.0*temp)
      END IF
      result1 = temp
      temp = result1*tloc(i, j)/(s_suth+tloc(i, j))
      mud(i, j) = betas*(tloc(i, j)*result1d+(result1-temp)*tlocd(i, j))&
&       /(s_suth+tloc(i, j))
      mu(i, j) = betas*temp
      arg1 = nx(i, j, 1)*nx(i, j, 1) + ny(i, j, 1)*ny(i, j, 1)
      result1 = SQRT(arg1)
      arg2 = nx(i, j, 2)*nx(i, j, 2) + ny(i, j, 2)*ny(i, j, 2)
      result2 = SQRT(arg2)
      dist = vol(i, j)/(result1+result2)
      arg1d = gam*(rom1*pintd+pint*rom1d)
      arg1 = gam*pint*rom1
      temp = SQRT(arg1)
      IF (arg1 .EQ. 0.0) THEN
        ccd = 0.0_8
      ELSE
        ccd = arg1d/(2.0*temp)
      END IF
      cc = temp
      arg1d = 2*velxi*velxid + 2*velyi*velyid
      arg1 = velxi*velxi + velyi*velyi
      temp = SQRT(arg1)
      IF (arg1 .EQ. 0.0) THEN
        result1d = 0.0_8
      ELSE
        result1d = arg1d/(2.0*temp)
      END IF
      result1 = temp
      vitcd = result1d + ccd
      vitc = result1 + cc
      dt_eulerd = -(dist*vitcd/vitc**2)
      dt_euler = dist/vitc
      temp = half*(dist*dist)
      temp0 = gampr*mu(i, j)
      dt_nsd = temp*(rord-ror*gampr*mud(i, j)/temp0)/temp0
      dt_ns = temp*(ror/temp0)
      IF (dt_euler .GT. dt_ns) THEN
        x1d = dt_nsd
        x1 = dt_ns
      ELSE
        x1d = dt_eulerd
        x1 = dt_euler
      END IF
      IF (x1 .LT. 1.d-15) THEN
        max1 = 1.d-15
        max1d = 0.0_8
      ELSE
        max1d = x1d
        max1 = x1
      END IF
! 1/dt
      dtm1d = -(cflm1*max1d/max1**2)
      dtm1 = cflm1/max1
!write(30101,*) "i,j    =  ", i,j
!write(30101,*) "dtm1   =  ", dtm1
!write(30101,*) "distm1 =  ", distm1
!write(30101,*) "cflm1  =  ", dtm1
!write(30101,*) "mu     =  ", mu(i,j)
! compute diagonal coefficient------------------------------------------------------
! dtcoef/tau0
      coefdiagd(i, j) = vol(i, j)*dtcoef*dtm1d
      coefdiag(i, j) = dtm1*dtcoef*vol(i, j)
    END DO
  END DO
  coefd = 0.0_8
! !for global timeStep
! dtm1save = 1.d-15
! do j = 1 , jm
! do i = 1 , im
! #include "lhs/PrimitivesLhs.F"
! #include "phys/viscosity.F"
! #include "lhs/time_step.F"
! IF (dtm1.gt.dtm1save) THEN
! dtm1save = dtm1
! ENDIF
! dtm1 = dtm1save
! enddo
! enddo
! !
! coefdiag(1:im,1:jm) = dtm1 * dtcoef * vol(1:im,1:jm) ! dtcoef/tau0
!
loop_kdir:DO kdir=1,2
    i0 = -kdir + 2
    j0 = kdir - 1
!
    DO j=1,jm+j0
      DO i=1,im+i0
        rold = wd(i-i0, j-j0, 1)
        rol = w(i-i0, j-j0, 1)
        rord = wd(i, j, 1)
        ror = w(i, j, 1)
        rom1ld = -(one*rold/rol**2)
        rom1l = one/rol
        rom1rd = -(one*rord/ror**2)
        rom1r = one/ror
        temp0 = 2.d0/(rol+ror)
        irod = -(temp0*(rold+rord)/(rol+ror))
        iro = temp0
        temp0 = w(i-i0, j-j0, 2)
        uud = half*(rom1l*wd(i-i0, j-j0, 2)+temp0*rom1ld+rom1r*wd(i, j, &
&         2)+w(i, j, 2)*rom1rd)
        uu = half*(temp0*rom1l+w(i, j, 2)*rom1r)
        temp0 = w(i-i0, j-j0, 3)
        vvd = half*(rom1l*wd(i-i0, j-j0, 3)+temp0*rom1ld+rom1r*wd(i, j, &
&         3)+w(i, j, 3)*rom1rd)
        vv = half*(temp0*rom1l+w(i, j, 3)*rom1r)
        temp0 = gam*rgaz*half
        ccd = temp0*(tlocd(i-i0, j-j0)+tlocd(i, j))
        cc = temp0*(tloc(i-i0, j-j0)+tloc(i, j))
        norm = nx(i, j, kdir)*nx(i, j, kdir) + ny(i, j, kdir)*ny(i, j, &
&         kdir)
        mutotd = half*gampr*(mud(i-i0, j-j0)+mud(i, j))
        mutot = half*gampr*(mu(i-i0, j-j0)+mu(i, j))
        specdiffd = volf(i, j, kdir)*norm*(iro*mutotd+mutot*irod)
        specdiff = mutot*norm*volf(i, j, kdir)*iro
        x2d = nx(i, j, kdir)*uud + ny(i, j, kdir)*vvd
        x2 = uu*nx(i, j, kdir) + vv*ny(i, j, kdir)
        IF (x2 .GE. 0.) THEN
          abs0d = x2d
          abs0 = x2
        ELSE
          abs0d = -x2d
          abs0 = -x2
        END IF
        arg1d = norm*ccd
        arg1 = cc*norm
        temp0 = SQRT(arg1)
        IF (arg1 .EQ. 0.0) THEN
          result1d = 0.0_8
        ELSE
          result1d = arg1d/(2.0*temp0)
        END IF
        result1 = temp0
        coefd(i, j, kdir) = one*(abs0d+result1d+two*specdiffd)
        coef(i, j, kdir) = one*(abs0+result1+two*specdiff)
      END DO
    END DO
    DO j=1,jm
      DO i=1,im
        coefdiagd(i, j) = coefdiagd(i, j) + coefd(i, j, kdir) + coefd(i+&
&         i0, j+j0, kdir)
        coefdiag(i, j) = coefdiag(i, j) + coef(i, j, kdir) + coef(i+i0, &
&         j+j0, kdir)
      END DO
    END DO
  END DO loop_kdir
  dwid = 0.0_8
  hnd = 0.0_8
  fid = 0.0_8
  dfid = 0.0_8
  gid = 0.0_8
  dgid = 0.0_8
loop_subite:DO l=1,lmax
    d2w = dw
    d2wd = 0.0_8
!
! Computation of the left hand side
!
loop_kdir_inner:DO kdir=1,2
      i0 = -kdir + 2
      j0 = kdir - 1
!
      DO j=1,jm+j0
        DO i=1,im+i0
!norm = dsqrt( nx(i,j,kdir)**2 + ny(i,j,kdir)**2)
          temp0 = half*nx(i, j, kdir)
          temp = half*ny(i, j, kdir)
          hnd(i, j, :) = temp0*(dfid(i-i0, j-j0, :)+dfid(i, j, :)) + &
&           temp*(dgid(i-i0, j-j0, :)+dgid(i, j, :))
          hn(i, j, :) = temp0*(dfi(i-i0, j-j0, :)+dfi(i, j, :)) + temp*(&
&           dgi(i-i0, j-j0, :)+dgi(i, j, :))
        END DO
      END DO
!
      DO j=1,jm
        DO i=1,im
          temp0 = coef(i+i0, j+j0, kdir)
          d2wd(i, j, :) = d2wd(i, j, :) + hnd(i, j, :) - hnd(i+i0, j+j0&
&           , :) + dwi(i-i0, j-j0, :)*coefd(i, j, kdir) + coef(i, j, &
&           kdir)*dwid(i-i0, j-j0, :) + dwi(i+i0, j+j0, :)*coefd(i+i0, j&
&           +j0, kdir) + temp0*dwid(i+i0, j+j0, :)
          d2w(i, j, :) = d2w(i, j, :) + hn(i, j, :) - hn(i+i0, j+j0, :) &
&           + coef(i, j, kdir)*dwi(i-i0, j-j0, :) + temp0*dwi(i+i0, j+j0&
&           , :)
        END DO
      END DO
    END DO loop_kdir_inner
!
! Computation of the intermediate increment
!
    DO j=1,jm
      DO i=1,im
        temp0 = one/coefdiag(i, j)
        diagm1d = -(temp0*coefdiagd(i, j)/coefdiag(i, j))
        diagm1 = temp0
        dwid(i, j, 1) = diagm1*d2wd(i, j, 1) + d2w(i, j, 1)*diagm1d
        dwi(i, j, 1) = d2w(i, j, 1)*diagm1
        dwid(i, j, 2) = diagm1*d2wd(i, j, 2) + d2w(i, j, 2)*diagm1d
        dwi(i, j, 2) = d2w(i, j, 2)*diagm1
        dwid(i, j, 3) = diagm1*d2wd(i, j, 3) + d2w(i, j, 3)*diagm1d
        dwi(i, j, 3) = d2w(i, j, 3)*diagm1
        dwid(i, j, 4) = diagm1*d2wd(i, j, 4) + d2w(i, j, 4)*diagm1d
        dwi(i, j, 4) = d2w(i, j, 4)*diagm1
        dwid(i, j, 5) = diagm1*d2wd(i, j, 5) + d2w(i, j, 5)*diagm1d
        dwi(i, j, 5) = d2w(i, j, 5)*diagm1
      END DO
    END DO
!
! Actualisation de wi
!
    DO j=1,jm
      DO i=1,im
        wid(:) = wd(i, j, :) + dwid(i, j, :)
        wi(:) = w(i, j, :) + dwi(i, j, :)
        temp0 = one/wi(1)
        rhom1d = -(temp0*wid(1)/wi(1))
        rhom1 = temp0
        velxid = rhom1*wid(2) + wi(2)*rhom1d
        velxi = wi(2)*rhom1
        velyid = rhom1*wid(3) + wi(3)*rhom1d
        velyi = wi(3)*rhom1
        velzid = rhom1*wid(4) + wi(4)*rhom1d
        velzi = wi(4)*rhom1
        temp0 = velxi*velxi + velyi*velyi + velzi*velzi
        pintd = gam1*(wid(5)-half*(temp0*wid(1)+wi(1)*(2*velxi*velxid+2*&
&         velyi*velyid+2*velzi*velzid)))
        pint = gam1*(wi(5)-half*(wi(1)*temp0))
!
! Actualisation des flux intermediaires
!
        fid(1) = wid(2)
        fi(1) = wi(2)
        fid(2) = velxi*wid(2) + wi(2)*velxid + pintd
        fi(2) = wi(2)*velxi + pint
        fid(3) = velyi*wid(2) + wi(2)*velyid
        fi(3) = wi(2)*velyi
        fid(4) = velzi*wid(2) + wi(2)*velzid
        fi(4) = wi(2)*velzi
        fid(5) = (wi(5)+pint)*velxid + velxi*(wid(5)+pintd)
        fi(5) = velxi*(wi(5)+pint)
        gid(1) = wid(3)
        gi(1) = wi(3)
        gid(2) = velxi*wid(3) + wi(3)*velxid
        gi(2) = wi(3)*velxi
        gid(3) = velyi*wid(3) + wi(3)*velyid + pintd
        gi(3) = wi(3)*velyi + pint
        gid(4) = velzi*wid(3) + wi(3)*velzid
        gi(4) = wi(3)*velzi
        gid(5) = (wi(5)+pint)*velyid + velyi*(wid(5)+pintd)
        gi(5) = velyi*(wi(5)+pint)
!
! Calcul des increments des flux
!
        dfid(i, j, :) = fid(:) - fd(i, j, :)
        dfi(i, j, :) = fi(:) - f(i, j, :)
        dgid(i, j, :) = gid(:) - gd(i, j, :)
        dgi(i, j, :) = gi(:) - g(i, j, :)
      END DO
    END DO
  END DO loop_subite
END SUBROUTINE IMPLI_MATRIX_FREE_2D_D
!

