! This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of jn_match_fx_2d in forward (tangent) mode (with options with!SliceDeadControl with!SliceDeadInstrs with!Stat
!icTaping):
!   variations   of useful results: fr
!   with respect to varying inputs: fd fr
!   RW status of diff variables: fd:in fr:in-out
!===============================================================================
!                          JOIN Match for Fluxes at faces
!===============================================================================
SUBROUTINE JN_MATCH_FX_2D_D(fr, frd, prr, gh1r, gh2r, gh3r, gh4r, imr, &
& jmr, fd, fdd, prd, gh1d, gh2d, gh3d, gh4d, imd, jmd, locr, locd, tr, &
& em, dimf)
  IMPLICIT NONE
!
! Variables for dimension -----------------------------------------
  INTEGER, INTENT(IN) :: imr, jmr, imd, jmd, dimf, em
  INTEGER, INTENT(IN) :: gh1r, gh2r, gh3r, gh4r
  INTEGER, INTENT(IN) :: gh1d, gh2d, gh3d, gh4d
! Input variables -------------------------------------------------
  CHARACTER(len=3), INTENT(IN) :: locr, locd
  REAL*8, DIMENSION(1-gh1d:imd+1+gh2d, 1-gh3d:jmd+1+gh4d, em, dimf), &
& INTENT(IN) :: fd
  REAL*8, DIMENSION(1-gh1d:imd+1+gh2d, 1-gh3d:jmd+1+gh4d, em, dimf), &
& INTENT(IN) :: fdd
  INTEGER, DIMENSION(2, 2), INTENT(IN) :: prr, prd
  INTEGER, DIMENSION(2), INTENT(IN) :: tr
! Output variables ------------------------------------------------
  REAL*8, DIMENSION(1-gh1r:imr+1+gh2r, 1-gh3r:jmr+1+gh4r, em, dimf), &
& INTENT(INOUT) :: fr
  REAL*8, DIMENSION(1-gh1r:imr+1+gh2r, 1-gh3r:jmr+1+gh4r, em, dimf), &
& INTENT(INOUT) :: frd
! Local variables -------------------------------------------------
  INTEGER, POINTER :: ind1, ind2
  INTEGER :: ir, jr
  INTEGER, TARGET :: id, jd
  INTEGER :: i, j, istep, jstep, idir, jdir, idd, jdd
  INTEGER :: direction, dird
  INTEGER, DIMENSION(2) :: sgnnx
  INTEGER, DIMENSION(2) :: highir, highjr
  INTEGER, DIMENSION(2) :: highid, highjd, i0, j0, i1, i2, j1, j2
  INTRINSIC SIGN
  INTRINSIC ABS
! -----------------------------------------------------------------
  istep = SIGN(1, tr(1))
  jstep = SIGN(1, tr(2))
  IF (tr(1) .GE. 0.) THEN
    idir = tr(1)
  ELSE
    idir = -tr(1)
  END IF
  IF (tr(2) .GE. 0.) THEN
    jdir = tr(2)
  ELSE
    jdir = -tr(2)
  END IF
  sgnnx(idir) = istep
  sgnnx(jdir) = jstep
!
  highir = 0
  highjr = 0
!
  i0 = 0
  j0 = 0
  i0(idir) = 1
  j0(jdir) = 1
!
  IF (locr .EQ. 'Ihi') THEN
    highir(1) = 1
  ELSE IF (locr .EQ. 'Jhi') THEN
    highjr(2) = 1
  END IF
!
  IF (locd .EQ. 'Ilo') THEN
    i0(1) = 0
    j0(1) = 0
  ELSE IF (locd .EQ. 'Ihi') THEN
    i0(1) = 0
    j0(1) = 0
  ELSE IF (locd .EQ. 'Jlo') THEN
    i0(2) = 0
    j0(2) = 0
  ELSE IF (locd .EQ. 'Jhi') THEN
    i0(2) = 0
    j0(2) = 0
  END IF
!
  IF (istep .EQ. 1) THEN
    i1(:) = 1
    i2(:) = prd(2, idir) - prd(1, idir) + 1 + i0(:)
  ELSE
    i1(:) = prd(2, idir) - prd(1, idir) + 1 + i0(:)
    i2(:) = 1
  END IF
!
  IF (jstep .EQ. 1) THEN
    j1(:) = 1
    j2(:) = prd(2, jdir) - prd(1, jdir) + 1 + j0(:)
  ELSE
    j1(:) = prd(2, jdir) - prd(1, jdir) + 1 + j0(:)
    j2(:) = 1
  END IF
!
  IF (idir .EQ. 1) THEN
    ind1 => id
    ind2 => jd
  ELSE IF (idir .EQ. 2) THEN
    ind1 => jd
    ind2 => id
  END IF
!
  DO direction=1,2
!
    idd = 1
    jdd = 1
    IF (tr(direction) .GE. 0.) THEN
      dird = tr(direction)
    ELSE
      dird = -tr(direction)
    END IF
    DO j=j1(dird),j2(dird),jstep
      DO i=i1(dird),i2(dird),istep
        ir = prr(1, 1) + idd - 1 + highir(direction)
        jr = prr(1, 2) + jdd - 1 + highjr(direction)
!
        frd(:, ir, jr, direction) = sgnnx(dird)*fdd(:, ind1, ind2, dird)
        idd = idd + 1
      END DO
      idd = 1
      jdd = jdd + 1
    END DO
  END DO
END SUBROUTINE JN_MATCH_FX_2D_D
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

