! This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of flux_num_dnc7_euler_nowall_2d in forward (tangent) mode (with options with!SliceDeadControl with!SliceDeadI
!nstrs with!StaticTaping):
!   variations   of useful results: residu
!   with respect to varying inputs: w
!   RW status of diff variables: w:in residu:out
! =============================================================================
!          consistent fluxes for DNC7 2D
! =============================================================================
!
SUBROUTINE FLUX_NUM_DNC7_EULER_NOWALL_2D_D(residu, residud, w, wd, x0, &
& y0, nx, ny, xc, yc, vol, gh, cp, cv, gam, rgaz, k2, k4, im, jm)
  IMPLICIT NONE
! variables for dimension -----------------------------------------
  INTEGER :: im, jm, gh
! required arguments ----------------------------------------------
! thermo
  REAL*8, INTENT(IN) :: cp, cv, gam, rgaz
! dissipation
  REAL*8, INTENT(IN) :: k2, k4
  REAL*8, DIMENSION(1-gh:im+gh+1, 1-gh:jm+gh+1), INTENT(IN) :: x0
  REAL*8, DIMENSION(1-gh:im+gh+1, 1-gh:jm+gh+1), INTENT(IN) :: y0
  REAL*8, DIMENSION(1-gh:im+gh+1, 1-gh:jm+gh+1, 2), INTENT(IN) :: nx
  REAL*8, DIMENSION(1-gh:im+gh+1, 1-gh:jm+gh+1, 2), INTENT(IN) :: ny
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: xc
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: yc
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh), INTENT(IN) :: vol
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 5), INTENT(IN) :: w
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 5), INTENT(IN) :: wd
! Returned objects ------------------------------------------------
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 5), INTENT(INOUT) :: residu
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 5), INTENT(INOUT) :: residud
! Non-required arguments -------------------------------------------
  REAL*8, DIMENSION(1-gh:im+gh+1, 1-gh:jm+gh+1, 5, 2) :: hn
  REAL*8, DIMENSION(1-gh:im+gh+1, 1-gh:jm+gh+1, 5, 2) :: hnd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 5) :: f, g
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 5) :: fd, gd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: velx
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: velxd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: vely
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: velyd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: velz
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: velzd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: tloc
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: tlocd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: p
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh) :: pd
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2) :: gradu, gradv, gradw
  REAL*8, DIMENSION(1-gh:im+gh, 1-gh:jm+gh, 2) :: gradud, gradvd
  REAL*8, DIMENSION(5) :: deltar, deltal, t
  INTEGER :: i, j, h
  REAL*8 :: nx_n, nx_s, nx_e, nx_o, volm1, ux, vx, wx, tx
  REAL*8 :: ny_n, ny_s, ny_e, ny_o, uy, vy, wy, ty
  REAL*8 :: val_n, val_s, val_e, val_o
  REAL*8 :: fxro1, fxro2, fxrou1, fxrou2, fxrov1, fxrov2, fxrow1, fxrow2&
& , fxroe1, fxroe2
  REAL*8 :: fxro1d, fxro2d, fxrou1d, fxrou2d, fxrov1d, fxrov2d, fxrow1d&
& , fxrow2d, fxroe1d, fxroe2d
  REAL*8 :: fvro1, fvro2, fvrou1, fvrou2, fvrov1, fvrov2, fvrow1, fvrow2&
& , fvroe1, fvroe2
  REAL*8 :: gvro1, gvro2, gvrou1, gvrou2, gvrov1, gvrov2, gvrow1, gvrow2&
& , gvroe1, gvroe2
  REAL*8 :: dissro1, dissro2, dissrou1, dissrou2, dissrov1, dissrov2, &
& dissrow1, dissrow2, dissroe1, dissroe2
  REAL*8 :: dissro1d, dissro2d, dissrou1d, dissrou2d, dissrov1d, &
& dissrov2d, dissrow1d, dissrow2d, dissroe1d, dissroe2d
  REAL*8 :: uu, vv, ww, ro, rom1, htot, eloc, ec
  REAL*8 :: rod, rom1d, htotd, elocd, ecd
  REAL*8 :: predro1, predrou1, predrov1, predrow1, predroe1, eps2, eps4
  REAL*8 :: predro1d, predrou1d, predrov1d, predrow1d, predroe1d, eps2d&
& , eps4d
  REAL*8 :: predro2, predrou2, predrov2, predrow2, predroe2, rspec
  REAL*8 :: predro2d, predrou2d, predrov2d, predrow2d, predroe2d, rspecd
  REAL*8 :: divu, divu2, vort2, dxm1, dym1, dxm2, dym2
  REAL*8 :: divud, divu2d, vort2d, dxm1d, dxm2d
  REAL*8 :: gui, gvi, gwi, gmui
  REAL*8 :: guid, gvid
  REAL*8 :: guj, gvj, gwj, gmuj
  REAL*8 :: gujd, gvjd
  REAL*8 :: nxloc, nyloc, sn, invsn, sc1, sc2
  REAL*8 :: rhom, rhomr, rhoml, rhom1l, c2l, c2r, rr, r, u, ur, ul, vr, &
& vl, wr, wl, c2x, nx2, ny2
  REAL*8 :: rhomrd, rhomld, c2ld, c2rd, rrd, rd, ud, urd, uld, vrd, vld&
& , c2xd
  REAL*8 :: ab, sq, ducros1, ducros2, k_sensor1, k_sensor2
  REAL*8 :: abd, sqd, ducros1d, ducros2d, k_sensor1d, k_sensor2d
  REAL*8 :: b1, b2, b3, b4, b5, c1, c2, c3, c4, c5, d1, d2, d3, d4, d5, &
& wiggle, denom, betas
  REAL*8 :: coef, omrr, test, diffro, diffrou, diffrov, diffrow, diffroe&
& , v
  REAL*8 :: coefd, omrrd, diffrod, diffroud, diffrovd, diffrowd, &
& diffroed, vd
  REAL*8 :: half, one, zero, two, twothird, fourth, twelfth, cvm1
  REAL*8 :: twentyfourth, ccross
  REAL*8 :: mach2, alpha, vn2, cprim
  INTRINSIC SQRT
  INTRINSIC ABS
  INTRINSIC TANH
  INTRINSIC MAX
  REAL*8 :: x1
  REAL*8 :: x1d
  REAL*8 :: x2
  REAL*8 :: x2d
  REAL*8 :: x3
  REAL*8 :: x3d
  REAL*8 :: x4
  REAL*8 :: x4d
  REAL*8 :: x5
  REAL*8 :: x5d
  REAL*8 :: x6
  REAL*8 :: x6d
  REAL*8 :: abs0
  REAL*8 :: abs0d
  REAL*8 :: abs1
  REAL*8 :: abs1d
  REAL*8 :: abs2
  REAL*8 :: abs2d
  REAL*8 :: abs3
  REAL*8 :: abs3d
  REAL*8 :: abs4
  REAL*8 :: abs4d
  REAL*8 :: abs5
  REAL*8 :: abs5d
  REAL*8 :: abs6
  REAL*8 :: abs6d
  REAL*8 :: abs7
  REAL*8 :: abs7d
  REAL*8 :: arg1
  REAL*8 :: arg1d
  REAL*8 :: temp
  REAL*8 :: temp0
! -----------------------------------------------------------------
!
  half = 0.5d0
  one = 1.d0
  zero = 0.d0
  two = 2.d0
  cvm1 = one/cv
! k2 = 1.d0
! k4 = 1.d0/1260.d0 already in coef for predictor
  denom = 1.d0/840.d0
! Coef for grad o8
! 4.d0/5.d0
  b1 = 672.d0*denom
!-1.d0/5.d0
  b2 = -(168.d0*denom)
! 4.d0/105.d0
  b3 = 32.d0*denom
!-1.d0/280.d0
  b4 = -(3.d0*denom)
!expression for FV
! c4 = a4
! c3 = c4 + a3
! c2 = c3 + a2
! c1 = c2 + a1
!
  c1 = 533.d0*denom
  c2 = -(139.d0*denom)
  c3 = 29.d0*denom
  c4 = -(3.d0*denom)
! coef for predictor
  denom = 1.d0/280.d0
!
  d1 = 35.d0*denom
  d2 = 21.d0*denom
  d3 = 7.d0*denom
  d4 = 1.d0*denom
  fd = 0.0_8
  gd = 0.0_8
  pd = 0.0_8
  velxd = 0.0_8
  velyd = 0.0_8
  velzd = 0.0_8
  tlocd = 0.0_8
! Primitives
  DO j=1-gh,jm+gh
!DIR$ IVDEP
    DO i=1-gh,im+gh
      rod = wd(i, j, 1)
      ro = w(i, j, 1)
      rom1d = -(one*rod/ro**2)
      rom1 = one/ro
      velxd(i, j) = rom1*wd(i, j, 2) + w(i, j, 2)*rom1d
      velx(i, j) = w(i, j, 2)*rom1
      velyd(i, j) = rom1*wd(i, j, 3) + w(i, j, 3)*rom1d
      vely(i, j) = w(i, j, 3)*rom1
      velzd(i, j) = rom1*wd(i, j, 4) + w(i, j, 4)*rom1d
      velz(i, j) = w(i, j, 4)*rom1
!
      ecd = half*(2*velx(i, j)*velxd(i, j)+2*vely(i, j)*velyd(i, j)+2*&
&       velz(i, j)*velzd(i, j))
      ec = half*(velx(i, j)*velx(i, j)+vely(i, j)*vely(i, j)+velz(i, j)*&
&       velz(i, j))
! ec  = HALF*( velx(i,j)*velx(i,j) &
!            + vely(i,j)*vely(i,j))
!
      temp = w(i, j, 5) - ec*ro
      elocd = rom1*(wd(i, j, 5)-ro*ecd-ec*rod) + temp*rom1d
      eloc = temp*rom1
!
      tlocd(i, j) = cvm1*elocd
      tloc(i, j) = eloc*cvm1
!
      pd(i, j) = (gam-one)*(eloc*rod+ro*elocd)
      p(i, j) = (gam-one)*ro*eloc
!  p(i,j)  = ro*rgaz*tloc(i,j)
      temp = w(i, j, 5) + p(i, j)
      htotd = rom1*(wd(i, j, 5)+pd(i, j)) + temp*rom1d
      htot = temp*rom1
      fd(i, j, 1) = wd(i, j, 2)
      fd(i, j, 2) = velx(i, j)*wd(i, j, 2) + w(i, j, 2)*velxd(i, j) + pd&
&       (i, j)
      fd(i, j, 3) = vely(i, j)*wd(i, j, 2) + w(i, j, 2)*velyd(i, j)
      fd(i, j, 4) = velz(i, j)*wd(i, j, 2) + w(i, j, 2)*velzd(i, j)
      fd(i, j, 5) = htot*wd(i, j, 2) + w(i, j, 2)*htotd
      gd(i, j, 1) = wd(i, j, 3)
      gd(i, j, 2) = velx(i, j)*wd(i, j, 3) + w(i, j, 3)*velxd(i, j)
      gd(i, j, 3) = vely(i, j)*wd(i, j, 3) + w(i, j, 3)*velyd(i, j) + pd&
&       (i, j)
      gd(i, j, 4) = velz(i, j)*wd(i, j, 3) + w(i, j, 3)*velzd(i, j)
      gd(i, j, 5) = htot*wd(i, j, 3) + w(i, j, 3)*htotd
    END DO
  END DO
  gradud = 0.0_8
  gradvd = 0.0_8
!h(i,j,1)  = w(i,j,4)
!h(i,j,2)  = w(i,j,4) * velx(i,j)
!h(i,j,3)  = w(i,j,4) * vely(i,j)
!h(i,j,4)  = w(i,j,4) * velz(i,j) + p(i,j)
!h(i,j,5)  = w(i,j,4) * htot
  DO j=1,jm
!DIR$ IVDEP
    DO i=1,im
      guid = b1*(velxd(i+1, j)-velxd(i-1, j)) + b2*(velxd(i+2, j)-velxd(&
&       i-2, j)) + b3*(velxd(i+3, j)-velxd(i-3, j)) + b4*(velxd(i+4, j)-&
&       velxd(i-4, j))
      gui = b1*(velx(i+1, j)-velx(i-1, j)) + b2*(velx(i+2, j)-velx(i-2, &
&       j)) + b3*(velx(i+3, j)-velx(i-3, j)) + b4*(velx(i+4, j)-velx(i-4&
&       , j))
      gvid = b1*(velyd(i+1, j)-velyd(i-1, j)) + b2*(velyd(i+2, j)-velyd(&
&       i-2, j)) + b3*(velyd(i+3, j)-velyd(i-3, j)) + b4*(velyd(i+4, j)-&
&       velyd(i-4, j))
      gvi = b1*(vely(i+1, j)-vely(i-1, j)) + b2*(vely(i+2, j)-vely(i-2, &
&       j)) + b3*(vely(i+3, j)-vely(i-3, j)) + b4*(vely(i+4, j)-vely(i-4&
&       , j))
      gujd = b1*(velxd(i, j+1)-velxd(i, j-1)) + b2*(velxd(i, j+2)-velxd(&
&       i, j-2)) + b3*(velxd(i, j+3)-velxd(i, j-3)) + b4*(velxd(i, j+4)-&
&       velxd(i, j-4))
      guj = b1*(velx(i, j+1)-velx(i, j-1)) + b2*(velx(i, j+2)-velx(i, j-&
&       2)) + b3*(velx(i, j+3)-velx(i, j-3)) + b4*(velx(i, j+4)-velx(i, &
&       j-4))
      gvjd = b1*(velyd(i, j+1)-velyd(i, j-1)) + b2*(velyd(i, j+2)-velyd(&
&       i, j-2)) + b3*(velyd(i, j+3)-velyd(i, j-3)) + b4*(velyd(i, j+4)-&
&       velyd(i, j-4))
      gvj = b1*(vely(i, j+1)-vely(i, j-1)) + b2*(vely(i, j+2)-vely(i, j-&
&       2)) + b3*(vely(i, j+3)-vely(i, j-3)) + b4*(vely(i, j+4)-vely(i, &
&       j-4))
      volm1 = one/vol(i, j)
      dxm1 = half*(nx(i, j, 1)+nx(i+1, j, 1))*volm1
      dxm2 = half*(nx(i, j, 2)+nx(i, j+1, 2))*volm1
      dym1 = half*(ny(i, j, 1)+ny(i+1, j, 1))*volm1
      dym2 = half*(ny(i, j, 2)+ny(i, j+1, 2))*volm1
      gradud(i, j, 1) = dxm1*guid + dxm2*gujd
      gradu(i, j, 1) = dxm1*gui + dxm2*guj
      gradvd(i, j, 1) = dxm1*gvid + dxm2*gvjd
      gradv(i, j, 1) = dxm1*gvi + dxm2*gvj
      gradud(i, j, 2) = dym1*guid + dym2*gujd
      gradu(i, j, 2) = dym1*gui + dym2*guj
      gradvd(i, j, 2) = dym1*gvid + dym2*gvjd
      gradv(i, j, 2) = dym1*gvi + dym2*gvj
    END DO
  END DO
! trick for ducros in dissipation
  DO i=1,2
    DO h=1,gh
      gradud(:, 1-h, :) = two*gradud(:, 2-h, :) - gradud(:, 3-h, :)
      gradu(:, 1-h, :) = two*gradu(:, 2-h, :) - gradu(:, 3-h, :)
      gradvd(:, 1-h, :) = two*gradvd(:, 2-h, :) - gradvd(:, 3-h, :)
      gradv(:, 1-h, :) = two*gradv(:, 2-h, :) - gradv(:, 3-h, :)
      gradud(:, jm+h, :) = two*gradud(:, jm-1+h, :) - gradud(:, jm-2+h, &
&       :)
      gradu(:, jm+h, :) = two*gradu(:, jm-1+h, :) - gradu(:, jm-2+h, :)
      gradvd(:, jm+h, :) = two*gradvd(:, jm-1+h, :) - gradvd(:, jm-2+h, &
&       :)
      gradv(:, jm+h, :) = two*gradv(:, jm-1+h, :) - gradv(:, jm-2+h, :)
      gradud(1-h, :, :) = two*gradud(2-h, :, :) - gradud(3-h, :, :)
      gradu(1-h, :, :) = two*gradu(2-h, :, :) - gradu(3-h, :, :)
      gradvd(1-h, :, :) = two*gradvd(2-h, :, :) - gradvd(3-h, :, :)
      gradv(1-h, :, :) = two*gradv(2-h, :, :) - gradv(3-h, :, :)
      gradud(im+h, :, :) = two*gradud(im-1+h, :, :) - gradud(im-2+h, :, &
&       :)
      gradu(im+h, :, :) = two*gradu(im-1+h, :, :) - gradu(im-2+h, :, :)
      gradvd(im+h, :, :) = two*gradvd(im-1+h, :, :) - gradvd(im-2+h, :, &
&       :)
      gradv(im+h, :, :) = two*gradv(im-1+h, :, :) - gradv(im-2+h, :, :)
    END DO
  END DO
  hnd = 0.0_8
  DO j=1,jm+1
!DIR$ IVDEP
    DO i=1,im+1
!
      fxro1d = nx(i, j, 1)*(c1*(fd(i, j, 1)+fd(i-1, j, 1))+c2*(fd(i+1, j&
&       , 1)+fd(i-2, j, 1))+c3*(fd(i+2, j, 1)+fd(i-3, j, 1))+c4*(fd(i+3&
&       , j, 1)+fd(i-4, j, 1))) + ny(i, j, 1)*(c1*(gd(i, j, 1)+gd(i-1, j&
&       , 1))+c2*(gd(i+1, j, 1)+gd(i-2, j, 1))+c3*(gd(i+2, j, 1)+gd(i-3&
&       , j, 1))+c4*(gd(i+3, j, 1)+gd(i-4, j, 1)))
      fxrou1d = nx(i, j, 1)*(c1*(fd(i, j, 2)+fd(i-1, j, 2))+c2*(fd(i+1, &
&       j, 2)+fd(i-2, j, 2))+c3*(fd(i+2, j, 2)+fd(i-3, j, 2))+c4*(fd(i+3&
&       , j, 2)+fd(i-4, j, 2))) + ny(i, j, 1)*(c1*(gd(i, j, 2)+gd(i-1, j&
&       , 2))+c2*(gd(i+1, j, 2)+gd(i-2, j, 2))+c3*(gd(i+2, j, 2)+gd(i-3&
&       , j, 2))+c4*(gd(i+3, j, 2)+gd(i-4, j, 2)))
      fxrov1d = nx(i, j, 1)*(c1*(fd(i, j, 3)+fd(i-1, j, 3))+c2*(fd(i+1, &
&       j, 3)+fd(i-2, j, 3))+c3*(fd(i+2, j, 3)+fd(i-3, j, 3))+c4*(fd(i+3&
&       , j, 3)+fd(i-4, j, 3))) + ny(i, j, 1)*(c1*(gd(i, j, 3)+gd(i-1, j&
&       , 3))+c2*(gd(i+1, j, 3)+gd(i-2, j, 3))+c3*(gd(i+2, j, 3)+gd(i-3&
&       , j, 3))+c4*(gd(i+3, j, 3)+gd(i-4, j, 3)))
      fxrow1d = nx(i, j, 1)*(c1*(fd(i, j, 4)+fd(i-1, j, 4))+c2*(fd(i+1, &
&       j, 4)+fd(i-2, j, 4))+c3*(fd(i+2, j, 4)+fd(i-3, j, 4))+c4*(fd(i+3&
&       , j, 4)+fd(i-4, j, 4))) + ny(i, j, 1)*(c1*(gd(i, j, 4)+gd(i-1, j&
&       , 4))+c2*(gd(i+1, j, 4)+gd(i-2, j, 4))+c3*(gd(i+2, j, 4)+gd(i-3&
&       , j, 4))+c4*(gd(i+3, j, 4)+gd(i-4, j, 4)))
      fxroe1d = nx(i, j, 1)*(c1*(fd(i, j, 5)+fd(i-1, j, 5))+c2*(fd(i+1, &
&       j, 5)+fd(i-2, j, 5))+c3*(fd(i+2, j, 5)+fd(i-3, j, 5))+c4*(fd(i+3&
&       , j, 5)+fd(i-4, j, 5))) + ny(i, j, 1)*(c1*(gd(i, j, 5)+gd(i-1, j&
&       , 5))+c2*(gd(i+1, j, 5)+gd(i-2, j, 5))+c3*(gd(i+2, j, 5)+gd(i-3&
&       , j, 5))+c4*(gd(i+3, j, 5)+gd(i-4, j, 5)))
      fxro2d = nx(i, j, 2)*(c1*(fd(i, j, 1)+fd(i, j-1, 1))+c2*(fd(i, j+1&
&       , 1)+fd(i, j-2, 1))+c3*(fd(i, j+2, 1)+fd(i, j-3, 1))+c4*(fd(i, j&
&       +3, 1)+fd(i, j-4, 1))) + ny(i, j, 2)*(c1*(gd(i, j, 1)+gd(i, j-1&
&       , 1))+c2*(gd(i, j+1, 1)+gd(i, j-2, 1))+c3*(gd(i, j+2, 1)+gd(i, j&
&       -3, 1))+c4*(gd(i, j+3, 1)+gd(i, j-4, 1)))
      fxrou2d = nx(i, j, 2)*(c1*(fd(i, j, 2)+fd(i, j-1, 2))+c2*(fd(i, j+&
&       1, 2)+fd(i, j-2, 2))+c3*(fd(i, j+2, 2)+fd(i, j-3, 2))+c4*(fd(i, &
&       j+3, 2)+fd(i, j-4, 2))) + ny(i, j, 2)*(c1*(gd(i, j, 2)+gd(i, j-1&
&       , 2))+c2*(gd(i, j+1, 2)+gd(i, j-2, 2))+c3*(gd(i, j+2, 2)+gd(i, j&
&       -3, 2))+c4*(gd(i, j+3, 2)+gd(i, j-4, 2)))
      fxrov2d = nx(i, j, 2)*(c1*(fd(i, j, 3)+fd(i, j-1, 3))+c2*(fd(i, j+&
&       1, 3)+fd(i, j-2, 3))+c3*(fd(i, j+2, 3)+fd(i, j-3, 3))+c4*(fd(i, &
&       j+3, 3)+fd(i, j-4, 3))) + ny(i, j, 2)*(c1*(gd(i, j, 3)+gd(i, j-1&
&       , 3))+c2*(gd(i, j+1, 3)+gd(i, j-2, 3))+c3*(gd(i, j+2, 3)+gd(i, j&
&       -3, 3))+c4*(gd(i, j+3, 3)+gd(i, j-4, 3)))
      fxrow2d = nx(i, j, 2)*(c1*(fd(i, j, 4)+fd(i, j-1, 4))+c2*(fd(i, j+&
&       1, 4)+fd(i, j-2, 4))+c3*(fd(i, j+2, 4)+fd(i, j-3, 4))+c4*(fd(i, &
&       j+3, 4)+fd(i, j-4, 4))) + ny(i, j, 2)*(c1*(gd(i, j, 4)+gd(i, j-1&
&       , 4))+c2*(gd(i, j+1, 4)+gd(i, j-2, 4))+c3*(gd(i, j+2, 4)+gd(i, j&
&       -3, 4))+c4*(gd(i, j+3, 4)+gd(i, j-4, 4)))
      fxroe2d = nx(i, j, 2)*(c1*(fd(i, j, 5)+fd(i, j-1, 5))+c2*(fd(i, j+&
&       1, 5)+fd(i, j-2, 5))+c3*(fd(i, j+2, 5)+fd(i, j-3, 5))+c4*(fd(i, &
&       j+3, 5)+fd(i, j-4, 5))) + ny(i, j, 2)*(c1*(gd(i, j, 5)+gd(i, j-1&
&       , 5))+c2*(gd(i, j+1, 5)+gd(i, j-2, 5))+c3*(gd(i, j+2, 5)+gd(i, j&
&       -3, 5))+c4*(gd(i, j+3, 5)+gd(i, j-4, 5)))
      predro1d = d4*wd(i-4, j, 1) - d3*wd(i-3, j, 1) + d2*wd(i-2, j, 1) &
&       - d1*wd(i-1, j, 1) + d1*wd(i, j, 1) - d2*wd(i+1, j, 1) + d3*wd(i&
&       +2, j, 1) - d4*wd(i+3, j, 1)
      predro1 = d4*w(i-4, j, 1) - d3*w(i-3, j, 1) + d2*w(i-2, j, 1) - d1&
&       *w(i-1, j, 1) + d1*w(i, j, 1) - d2*w(i+1, j, 1) + d3*w(i+2, j, 1&
&       ) - d4*w(i+3, j, 1)
      predrou1d = d4*wd(i-4, j, 2) - d3*wd(i-3, j, 2) + d2*wd(i-2, j, 2)&
&       - d1*wd(i-1, j, 2) + d1*wd(i, j, 2) - d2*wd(i+1, j, 2) + d3*wd(i&
&       +2, j, 2) - d4*wd(i+3, j, 2)
      predrou1 = d4*w(i-4, j, 2) - d3*w(i-3, j, 2) + d2*w(i-2, j, 2) - &
&       d1*w(i-1, j, 2) + d1*w(i, j, 2) - d2*w(i+1, j, 2) + d3*w(i+2, j&
&       , 2) - d4*w(i+3, j, 2)
      predrov1d = d4*wd(i-4, j, 3) - d3*wd(i-3, j, 3) + d2*wd(i-2, j, 3)&
&       - d1*wd(i-1, j, 3) + d1*wd(i, j, 3) - d2*wd(i+1, j, 3) + d3*wd(i&
&       +2, j, 3) - d4*wd(i+3, j, 3)
      predrov1 = d4*w(i-4, j, 3) - d3*w(i-3, j, 3) + d2*w(i-2, j, 3) - &
&       d1*w(i-1, j, 3) + d1*w(i, j, 3) - d2*w(i+1, j, 3) + d3*w(i+2, j&
&       , 3) - d4*w(i+3, j, 3)
      predrow1d = d4*wd(i-4, j, 4) - d3*wd(i-3, j, 4) + d2*wd(i-2, j, 4)&
&       - d1*wd(i-1, j, 4) + d1*wd(i, j, 4) - d2*wd(i+1, j, 4) + d3*wd(i&
&       +2, j, 4) - d4*wd(i+3, j, 4)
      predrow1 = d4*w(i-4, j, 4) - d3*w(i-3, j, 4) + d2*w(i-2, j, 4) - &
&       d1*w(i-1, j, 4) + d1*w(i, j, 4) - d2*w(i+1, j, 4) + d3*w(i+2, j&
&       , 4) - d4*w(i+3, j, 4)
      predroe1d = d4*wd(i-4, j, 5) - d3*wd(i-3, j, 5) + d2*wd(i-2, j, 5)&
&       - d1*wd(i-1, j, 5) + d1*wd(i, j, 5) - d2*wd(i+1, j, 5) + d3*wd(i&
&       +2, j, 5) - d4*wd(i+3, j, 5)
      predroe1 = d4*w(i-4, j, 5) - d3*w(i-3, j, 5) + d2*w(i-2, j, 5) - &
&       d1*w(i-1, j, 5) + d1*w(i, j, 5) - d2*w(i+1, j, 5) + d3*w(i+2, j&
&       , 5) - d4*w(i+3, j, 5)
      predro2d = d4*wd(i, j-4, 1) - d3*wd(i, j-3, 1) + d2*wd(i, j-2, 1) &
&       - d1*wd(i, j-1, 1) + d1*wd(i, j, 1) - d2*wd(i, j+1, 1) + d3*wd(i&
&       , j+2, 1) - d4*wd(i, j+3, 1)
      predro2 = d4*w(i, j-4, 1) - d3*w(i, j-3, 1) + d2*w(i, j-2, 1) - d1&
&       *w(i, j-1, 1) + d1*w(i, j, 1) - d2*w(i, j+1, 1) + d3*w(i, j+2, 1&
&       ) - d4*w(i, j+3, 1)
      predrou2d = d4*wd(i, j-4, 2) - d3*wd(i, j-3, 2) + d2*wd(i, j-2, 2)&
&       - d1*wd(i, j-1, 2) + d1*wd(i, j, 2) - d2*wd(i, j+1, 2) + d3*wd(i&
&       , j+2, 2) - d4*wd(i, j+3, 2)
      predrou2 = d4*w(i, j-4, 2) - d3*w(i, j-3, 2) + d2*w(i, j-2, 2) - &
&       d1*w(i, j-1, 2) + d1*w(i, j, 2) - d2*w(i, j+1, 2) + d3*w(i, j+2&
&       , 2) - d4*w(i, j+3, 2)
      predrov2d = d4*wd(i, j-4, 3) - d3*wd(i, j-3, 3) + d2*wd(i, j-2, 3)&
&       - d1*wd(i, j-1, 3) + d1*wd(i, j, 3) - d2*wd(i, j+1, 3) + d3*wd(i&
&       , j+2, 3) - d4*wd(i, j+3, 3)
      predrov2 = d4*w(i, j-4, 3) - d3*w(i, j-3, 3) + d2*w(i, j-2, 3) - &
&       d1*w(i, j-1, 3) + d1*w(i, j, 3) - d2*w(i, j+1, 3) + d3*w(i, j+2&
&       , 3) - d4*w(i, j+3, 3)
      predrow2d = d4*wd(i, j-4, 4) - d3*wd(i, j-3, 4) + d2*wd(i, j-2, 4)&
&       - d1*wd(i, j-1, 4) + d1*wd(i, j, 4) - d2*wd(i, j+1, 4) + d3*wd(i&
&       , j+2, 4) - d4*wd(i, j+3, 4)
      predrow2 = d4*w(i, j-4, 4) - d3*w(i, j-3, 4) + d2*w(i, j-2, 4) - &
&       d1*w(i, j-1, 4) + d1*w(i, j, 4) - d2*w(i, j+1, 4) + d3*w(i, j+2&
&       , 4) - d4*w(i, j+3, 4)
      predroe2d = d4*wd(i, j-4, 5) - d3*wd(i, j-3, 5) + d2*wd(i, j-2, 5)&
&       - d1*wd(i, j-1, 5) + d1*wd(i, j, 5) - d2*wd(i, j+1, 5) + d3*wd(i&
&       , j+2, 5) - d4*wd(i, j+3, 5)
      predroe2 = d4*w(i, j-4, 5) - d3*w(i, j-3, 5) + d2*w(i, j-2, 5) - &
&       d1*w(i, j-1, 5) + d1*w(i, j, 5) - d2*w(i, j+1, 5) + d3*w(i, j+2&
&       , 5) - d4*w(i, j+3, 5)
!1st direction
      rhomrd = wd(i, j, 1)
      rhomr = w(i, j, 1)
      temp = w(i, j, 2)/rhomr
      urd = (wd(i, j, 2)-temp*rhomrd)/rhomr
      ur = temp
      temp = w(i, j, 3)/rhomr
      vrd = (wd(i, j, 3)-temp*rhomrd)/rhomr
      vr = temp
      c2rd = gam*rgaz*tlocd(i, j)
      c2r = gam*rgaz*tloc(i, j)
!
      rhomld = wd(i-1, j, 1)
      rhoml = w(i-1, j, 1)
      temp = w(i-1, j, 2)/rhoml
      uld = (wd(i-1, j, 2)-temp*rhomld)/rhoml
      ul = temp
      temp = w(i-1, j, 3)/rhoml
      vld = (wd(i-1, j, 3)-temp*rhomld)/rhoml
      vl = temp
      c2ld = gam*rgaz*tlocd(i-1, j)
      c2l = gam*rgaz*tloc(i-1, j)
!
      temp = rhomr/rhoml
      temp0 = SQRT(temp)
      IF (temp .EQ. 0.0) THEN
        rd = 0.0_8
      ELSE
        rd = (rhomrd-temp*rhomld)/(2.0*temp0*rhoml)
      END IF
      r = temp0
      temp0 = one/(one+r)
      rrd = -(temp0*rd/(one+r))
      rr = temp0
      omrrd = -rrd
      omrr = one - rr
!
      ud = rr*uld + ul*rrd + omrr*urd + ur*omrrd
      u = ul*rr + ur*omrr
      vd = rr*vld + vl*rrd + omrr*vrd + vr*omrrd
      v = vl*rr + vr*omrr
!
      c2xd = rr*c2ld + c2l*rrd + omrr*c2rd + c2r*omrrd
      c2x = c2l*rr + c2r*omrr
      nx2 = nx(i, j, 1)*nx(i, j, 1) + ny(i, j, 1)*ny(i, j, 1)
      x1d = nx(i, j, 1)*ud + ny(i, j, 1)*vd
      x1 = nx(i, j, 1)*u + ny(i, j, 1)*v
      IF (x1 .GE. 0.) THEN
        abd = x1d
        ab = x1
      ELSE
        abd = -x1d
        ab = -x1
      END IF
      temp0 = SQRT(nx2*c2x)
      IF (nx2*c2x .EQ. 0.0) THEN
        sqd = 0.0_8
      ELSE
        sqd = nx2*c2xd/(2.0*temp0)
      END IF
      sq = temp0
!
      rspecd = abd + sqd
      rspec = ab + sq
      IF (p(i-1, j) - two*p(i, j) + p(i+1, j) .GE. 0.) THEN
        abs0d = pd(i-1, j) - two*pd(i, j) + pd(i+1, j)
        abs0 = p(i-1, j) - two*p(i, j) + p(i+1, j)
      ELSE
        abs0d = two*pd(i, j) - pd(i-1, j) - pd(i+1, j)
        abs0 = -(p(i-1, j)-two*p(i, j)+p(i+1, j))
      END IF
      x3d = pd(i-1, j) + two*pd(i, j) + pd(i+1, j)
      x3 = p(i-1, j) + two*p(i, j) + p(i+1, j)
      IF (x3 .GE. 0.) THEN
        abs4d = x3d
        abs4 = x3
      ELSE
        abs4d = -x3d
        abs4 = -x3
      END IF
!
! correction Rossow JCP 2000
! #include "rhs/spectralradiusRossow_i.F"
!1st direction
      k_sensor1d = (abs0d-abs0*abs4d/abs4)/abs4
      k_sensor1 = abs0/abs4
      IF (p(i-2, j) - two*p(i-1, j) + p(i, j) .GE. 0.) THEN
        abs1d = pd(i-2, j) - two*pd(i-1, j) + pd(i, j)
        abs1 = p(i-2, j) - two*p(i-1, j) + p(i, j)
      ELSE
        abs1d = two*pd(i-1, j) - pd(i-2, j) - pd(i, j)
        abs1 = -(p(i-2, j)-two*p(i-1, j)+p(i, j))
      END IF
      x4d = pd(i-2, j) + two*pd(i-1, j) + pd(i, j)
      x4 = p(i-2, j) + two*p(i-1, j) + p(i, j)
      IF (x4 .GE. 0.) THEN
        abs5d = x4d
        abs5 = x4
      ELSE
        abs5d = -x4d
        abs5 = -x4
      END IF
      k_sensor2d = (abs1d-abs1*abs5d/abs5)/abs5
      k_sensor2 = abs1/abs5
      divud = gradud(i, j, 1) + gradvd(i, j, 2)
      divu = gradu(i, j, 1) + gradv(i, j, 2)
      divu2d = 2*divu*divud
      divu2 = divu*divu
      vort2d = 2*(gradv(i, j, 1)-gradu(i, j, 2))*(gradvd(i, j, 1)-gradud&
&       (i, j, 2))
      vort2 = (gradv(i, j, 1)-gradu(i, j, 2))*(gradv(i, j, 1)-gradu(i, j&
&       , 2))
      temp0 = divu2/(divu2+vort2+1d-15)
      ducros1d = (divu2d-temp0*(divu2d+vort2d))/(divu2+vort2+1d-15)
      ducros1 = temp0
      temp0 = 10.d0*vol(i, j)
      temp = divu/(sq+1d-15)
      arg1d = temp0*(divud-temp*sqd)/(sq+1d-15)
      arg1 = temp0*temp + 2.5d0
      dxm1d = -(half*(1.0-TANH(arg1)**2)*arg1d)
      dxm1 = half*(one-TANH(arg1))
      divud = gradud(i-1, j, 1) + gradvd(i-1, j, 2)
      divu = gradu(i-1, j, 1) + gradv(i-1, j, 2)
      divu2d = 2*divu*divud
      divu2 = divu*divu
      vort2d = 2*(gradv(i-1, j, 1)-gradu(i-1, j, 2))*(gradvd(i-1, j, 1)-&
&       gradud(i-1, j, 2))
      vort2 = (gradv(i-1, j, 1)-gradu(i-1, j, 2))*(gradv(i-1, j, 1)-&
&       gradu(i-1, j, 2))
      temp0 = divu2/(divu2+vort2+1d-15)
      ducros2d = (divu2d-temp0*(divu2d+vort2d))/(divu2+vort2+1d-15)
      ducros2 = temp0
      temp0 = 10.d0*vol(i, j)
      temp = divu/(sq+1d-15)
      arg1d = temp0*(divud-temp*sqd)/(sq+1d-15)
      arg1 = temp0*temp + 2.5d0
      dxm2d = -(half*(1.0-TANH(arg1)**2)*arg1d)
      dxm2 = half*(one-TANH(arg1))
      IF (k_sensor1*ducros1*dxm1 .LT. k_sensor2*ducros2*dxm2) THEN
        coefd = dxm2*(ducros2*k_sensor2d+k_sensor2*ducros2d) + k_sensor2&
&         *ducros2*dxm2d
        coef = k_sensor2*ducros2*dxm2
      ELSE
        coefd = dxm1*(ducros1*k_sensor1d+k_sensor1*ducros1d) + k_sensor1&
&         *ducros1*dxm1d
        coef = k_sensor1*ducros1*dxm1
      END IF
!     ! extension of shock capturing
!
!    k_sensor1 = ABS(p(i,j) - TWO*p(i+1,j) + p(i+2,j)) / &
!                ABS(p(i,j) + TWO*p(i+1,j) + p(i+2,j))
!
!    k_sensor2 = ABS(p(i-3,j) - TWO*p(i-2,j) + p(i-1,j)) / &
!                ABS(p(i-3,j) + TWO*p(i-2,j) + p(i-1,j))
!
!    divu2     = (gradu(i+1,j,1)+gradv(i+1,j,2)) * (gradu(i+1,j,1)+gradv(i+1,j,2))
!    vort2     = (gradv(i+1,j,1)-gradu(i+1,j,2)) * (gradv(i+1,j,1)-gradu(i+1,j,2))
!    ducros1   = divu2/(divu2+vort2+1d-15)
!
!    divu2     = (gradu(i-2,j,1)+gradv(i-2,j,2)) * (gradu(i-2,j,1)+gradv(i-2,j,2))
!    vort2     = (gradv(i-2,j,1)-gradu(i-2,j,2)) * (gradv(i-2,j,1)-gradu(i-2,j,2))
!    ducros2   = divu2/(divu2+vort2+1d-15)
!
!    coef      = MAX( k_sensor1*ducros1, &
!                      k_sensor2*ducros2, coef)
!
      eps2d = k2*coefd
      eps2 = k2*coef
      IF (zero .LT. k4 - 12.d0*eps2) THEN
        eps4d = -(12.d0*eps2d)
        eps4 = k4 - 12.d0*eps2
      ELSE
        eps4 = zero
        eps4d = 0.0_8
      END IF
      diffrod = half*(wd(i, j, 1)-wd(i-1, j, 1))
      diffro = half*(w(i, j, 1)-w(i-1, j, 1))
      diffroud = half*(wd(i, j, 2)-wd(i-1, j, 2))
      diffrou = half*(w(i, j, 2)-w(i-1, j, 2))
      diffrovd = half*(wd(i, j, 3)-wd(i-1, j, 3))
      diffrov = half*(w(i, j, 3)-w(i-1, j, 3))
      diffrowd = half*(wd(i, j, 4)-wd(i-1, j, 4))
      diffrow = half*(w(i, j, 4)-w(i-1, j, 4))
      diffroed = half*(wd(i, j, 5)-wd(i-1, j, 5))
      diffroe = half*(w(i, j, 5)-w(i-1, j, 5))
!
!
!     if (eps4.gt.1.d-12) then
! #include "rhs/wiggle_diri.F"
!     endif
      temp0 = eps2*diffro + eps4*predro1
      dissro1d = temp0*rspecd + rspec*(diffro*eps2d+eps2*diffrod+predro1&
&       *eps4d+eps4*predro1d)
      temp0 = eps2*diffrou + eps4*predrou1
      dissrou1d = temp0*rspecd + rspec*(diffrou*eps2d+eps2*diffroud+&
&       predrou1*eps4d+eps4*predrou1d)
      temp0 = eps2*diffrov + eps4*predrov1
      dissrov1d = temp0*rspecd + rspec*(diffrov*eps2d+eps2*diffrovd+&
&       predrov1*eps4d+eps4*predrov1d)
      temp0 = eps2*diffrow + eps4*predrow1
      dissrow1d = temp0*rspecd + rspec*(diffrow*eps2d+eps2*diffrowd+&
&       predrow1*eps4d+eps4*predrow1d)
      temp0 = eps2*diffroe + eps4*predroe1
      dissroe1d = temp0*rspecd + rspec*(diffroe*eps2d+eps2*diffroed+&
&       predroe1*eps4d+eps4*predroe1d)
!1st direction
      rhomrd = wd(i, j, 1)
      rhomr = w(i, j, 1)
      temp0 = w(i, j, 2)/rhomr
      urd = (wd(i, j, 2)-temp0*rhomrd)/rhomr
      ur = temp0
      temp0 = w(i, j, 3)/rhomr
      vrd = (wd(i, j, 3)-temp0*rhomrd)/rhomr
      vr = temp0
      c2rd = gam*rgaz*tlocd(i, j)
      c2r = gam*rgaz*tloc(i, j)
!
      rhomld = wd(i, j-1, 1)
      rhoml = w(i, j-1, 1)
      temp0 = w(i, j-1, 2)/rhoml
      uld = (wd(i, j-1, 2)-temp0*rhomld)/rhoml
      ul = temp0
      temp0 = w(i, j-1, 3)/rhoml
      vld = (wd(i, j-1, 3)-temp0*rhomld)/rhoml
      vl = temp0
      c2ld = gam*rgaz*tlocd(i, j-1)
      c2l = gam*rgaz*tloc(i, j-1)
!
      temp0 = rhomr/rhoml
      temp = SQRT(temp0)
      IF (temp0 .EQ. 0.0) THEN
        rd = 0.0_8
      ELSE
        rd = (rhomrd-temp0*rhomld)/(2.0*temp*rhoml)
      END IF
      r = temp
      temp0 = one/(one+r)
      rrd = -(temp0*rd/(one+r))
      rr = temp0
      omrrd = -rrd
      omrr = one - rr
!
      ud = rr*uld + ul*rrd + omrr*urd + ur*omrrd
      u = ul*rr + ur*omrr
      vd = rr*vld + vl*rrd + omrr*vrd + vr*omrrd
      v = vl*rr + vr*omrr
!
      c2xd = rr*c2ld + c2l*rrd + omrr*c2rd + c2r*omrrd
      c2x = c2l*rr + c2r*omrr
      nx2 = nx(i, j, 2)*nx(i, j, 2) + ny(i, j, 2)*ny(i, j, 2)
      x2d = nx(i, j, 2)*ud + ny(i, j, 2)*vd
      x2 = nx(i, j, 2)*u + ny(i, j, 2)*v
      IF (x2 .GE. 0.) THEN
        abd = x2d
        ab = x2
      ELSE
        abd = -x2d
        ab = -x2
      END IF
      temp0 = SQRT(nx2*c2x)
      IF (nx2*c2x .EQ. 0.0) THEN
        sqd = 0.0_8
      ELSE
        sqd = nx2*c2xd/(2.0*temp0)
      END IF
      sq = temp0
!
      rspecd = abd + sqd
      rspec = ab + sq
      IF (p(i, j-1) - two*p(i, j) + p(i, j+1) .GE. 0.) THEN
        abs2d = pd(i, j-1) - two*pd(i, j) + pd(i, j+1)
        abs2 = p(i, j-1) - two*p(i, j) + p(i, j+1)
      ELSE
        abs2d = two*pd(i, j) - pd(i, j-1) - pd(i, j+1)
        abs2 = -(p(i, j-1)-two*p(i, j)+p(i, j+1))
      END IF
      x5d = pd(i, j-1) + two*pd(i, j) + pd(i, j+1)
      x5 = p(i, j-1) + two*p(i, j) + p(i, j+1)
      IF (x5 .GE. 0.) THEN
        abs6d = x5d
        abs6 = x5
      ELSE
        abs6d = -x5d
        abs6 = -x5
      END IF
!
! correction Rossow JCP 2000
! #include "rhs/spectralradiusRossow_j.F"
! 2nd direction
      k_sensor1d = (abs2d-abs2*abs6d/abs6)/abs6
      k_sensor1 = abs2/abs6
      IF (p(i, j-2) - two*p(i, j-1) + p(i, j) .GE. 0.) THEN
        abs3d = pd(i, j-2) - two*pd(i, j-1) + pd(i, j)
        abs3 = p(i, j-2) - two*p(i, j-1) + p(i, j)
      ELSE
        abs3d = two*pd(i, j-1) - pd(i, j-2) - pd(i, j)
        abs3 = -(p(i, j-2)-two*p(i, j-1)+p(i, j))
      END IF
      x6d = pd(i, j-2) + two*pd(i, j-1) + pd(i, j)
      x6 = p(i, j-2) + two*p(i, j-1) + p(i, j)
      IF (x6 .GE. 0.) THEN
        abs7d = x6d
        abs7 = x6
      ELSE
        abs7d = -x6d
        abs7 = -x6
      END IF
      k_sensor2d = (abs3d-abs3*abs7d/abs7)/abs7
      k_sensor2 = abs3/abs7
!     ducros1 is done in dissipation_ducros_x
      divud = gradud(i, j-1, 1) + gradvd(i, j-1, 2)
      divu = gradu(i, j-1, 1) + gradv(i, j-1, 2)
      divu2d = 2*divu*divud
      divu2 = divu*divu
      vort2d = 2*(gradv(i, j-1, 1)-gradu(i, j-1, 2))*(gradvd(i, j-1, 1)-&
&       gradud(i, j-1, 2))
      vort2 = (gradv(i, j-1, 1)-gradu(i, j-1, 2))*(gradv(i, j-1, 1)-&
&       gradu(i, j-1, 2))
      temp0 = divu2/(divu2+vort2+1d-15)
      ducros2d = (divu2d-temp0*(divu2d+vort2d))/(divu2+vort2+1d-15)
      ducros2 = temp0
!sq = sound/dx
      temp0 = 10.d0*vol(i, j)
      temp = divu/(sq+1d-15)
      arg1d = temp0*(divud-temp*sqd)/(sq+1d-15)
      arg1 = temp0*temp + 2.5d0
      dxm2d = -(half*(1.0-TANH(arg1)**2)*arg1d)
      dxm2 = half*(one-TANH(arg1))
      IF (k_sensor1*ducros1*dxm1 .LT. k_sensor2*ducros2*dxm2) THEN
        coefd = dxm2*(ducros2*k_sensor2d+k_sensor2*ducros2d) + k_sensor2&
&         *ducros2*dxm2d
        coef = k_sensor2*ducros2*dxm2
      ELSE
        coefd = dxm1*(ducros1*k_sensor1d+k_sensor1*ducros1d) + k_sensor1&
&         *ducros1*dxm1d
        coef = k_sensor1*ducros1*dxm1
      END IF
! extension of shock capturing
!    k_sensor1 = ABS(p(i,j) - TWO*p(i,j+1) + p(i,j+2)) / &
!                ABS(p(i,j) + TWO*p(i,j+1) + p(i,j+2))
!
!    k_sensor2 = ABS(p(i,j-3) - TWO*p(i,j-2) + p(i,j-1)) / &
!                ABS(p(i,j-3) + TWO*p(i,j-2) + p(i,j-1))
!
!    divu2     = (gradu(i,j+1,1)+gradv(i,j+1,2)) * (gradu(i,j+1,1)+gradv(i,j+1,2))
!    vort2     = (gradv(i,j+1,1)-gradu(i,j+1,2)) * (gradv(i,j+1,1)-gradu(i,j+1,2))
!    ducros1   = divu2/(divu2+vort2+1d-15)
!
!    divu2     = (gradu(i,j-2,1)+gradv(i,j-2,2)) * (gradu(i,j-2,1)+gradv(i,j-2,2))
!    vort2     = (gradv(i,j-2,1)-gradu(i,j-2,2)) * (gradv(i,j-2,1)-gradu(i,j-2,2))
!    ducros2   = divu2/(divu2+vort2+1d-15)
!
!    coef      = MAX( k_sensor1*ducros1, &
!                     k_sensor2*ducros2, coef)
      eps2d = k2*coefd
      eps2 = k2*coef
      IF (zero .LT. k4 - 12.d0*eps2) THEN
        eps4d = -(12.d0*eps2d)
        eps4 = k4 - 12.d0*eps2
      ELSE
        eps4 = zero
        eps4d = 0.0_8
      END IF
      diffrod = half*(wd(i, j, 1)-wd(i, j-1, 1))
      diffro = half*(w(i, j, 1)-w(i, j-1, 1))
      diffroud = half*(wd(i, j, 2)-wd(i, j-1, 2))
      diffrou = half*(w(i, j, 2)-w(i, j-1, 2))
      diffrovd = half*(wd(i, j, 3)-wd(i, j-1, 3))
      diffrov = half*(w(i, j, 3)-w(i, j-1, 3))
      diffrowd = half*(wd(i, j, 4)-wd(i, j-1, 4))
      diffrow = half*(w(i, j, 4)-w(i, j-1, 4))
      diffroed = half*(wd(i, j, 5)-wd(i, j-1, 5))
      diffroe = half*(w(i, j, 5)-w(i, j-1, 5))
!
!
!     if (eps4.gt.1.d-12) then
! #include "rhs/wiggle_dirj.F"
!     endif
!
      temp0 = eps2*diffro + eps4*predro2
      dissro2d = temp0*rspecd + rspec*(diffro*eps2d+eps2*diffrod+predro2&
&       *eps4d+eps4*predro2d)
      temp0 = eps2*diffrou + eps4*predrou2
      dissrou2d = temp0*rspecd + rspec*(diffrou*eps2d+eps2*diffroud+&
&       predrou2*eps4d+eps4*predrou2d)
      temp0 = eps2*diffrov + eps4*predrov2
      dissrov2d = temp0*rspecd + rspec*(diffrov*eps2d+eps2*diffrovd+&
&       predrov2*eps4d+eps4*predrov2d)
      temp0 = eps2*diffrow + eps4*predrow2
      dissrow2d = temp0*rspecd + rspec*(diffrow*eps2d+eps2*diffrowd+&
&       predrow2*eps4d+eps4*predrow2d)
      temp0 = eps2*diffroe + eps4*predroe2
      dissroe2d = temp0*rspecd + rspec*(diffroe*eps2d+eps2*diffroed+&
&       predroe2*eps4d+eps4*predroe2d)
      hnd(i, j, 1, 1) = fxro1d - dissro1d
      hnd(i, j, 2, 1) = fxrou1d - dissrou1d
      hnd(i, j, 3, 1) = fxrov1d - dissrov1d
      hnd(i, j, 4, 1) = fxrow1d - dissrow1d
      hnd(i, j, 5, 1) = fxroe1d - dissroe1d
      hnd(i, j, 1, 2) = fxro2d - dissro2d
      hnd(i, j, 2, 2) = fxrou2d - dissrou2d
      hnd(i, j, 3, 2) = fxrov2d - dissrov2d
      hnd(i, j, 4, 2) = fxrow2d - dissrow2d
      hnd(i, j, 5, 2) = fxroe2d - dissroe2d
    END DO
  END DO
  residud = 0.0_8
!
! fluxes balance
  DO j=1,jm
!GCC$ IVDEP
    DO i=1,im
      residud(i, j, 1) = hnd(i, j, 1, 1) - hnd(i+1, j, 1, 1) + hnd(i, j&
&       , 1, 2) - hnd(i, j+1, 1, 2)
      residud(i, j, 2) = hnd(i, j, 2, 1) - hnd(i+1, j, 2, 1) + hnd(i, j&
&       , 2, 2) - hnd(i, j+1, 2, 2)
      residud(i, j, 3) = hnd(i, j, 3, 1) - hnd(i+1, j, 3, 1) + hnd(i, j&
&       , 3, 2) - hnd(i, j+1, 3, 2)
      residud(i, j, 4) = hnd(i, j, 4, 1) - hnd(i+1, j, 4, 1) + hnd(i, j&
&       , 4, 2) - hnd(i, j+1, 4, 2)
      residud(i, j, 5) = hnd(i, j, 5, 1) - hnd(i+1, j, 5, 1) + hnd(i, j&
&       , 5, 2) - hnd(i, j+1, 5, 2)
    END DO
  END DO
END SUBROUTINE FLUX_NUM_DNC7_EULER_NOWALL_2D_D
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

